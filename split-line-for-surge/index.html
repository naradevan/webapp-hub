<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split Line FDT to FAT via POLE - Polyline Guided</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
  // Load GA setelah page fully loaded
  window.addEventListener('load', function() {
    var script = document.createElement('script');
    script.async = true;
    script.src = 'https://www.googletagmanager.com/gtag/js?id=G-T12DERDD3M';
    document.head.appendChild(script);
    
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-T12DERDD3M');
  });
</script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 30px;
            text-align: center;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 40px;
        }
        
        .control-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        .file-input {
            display: none;
        }
        
        .file-input-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            min-height: 80px;
        }
        
        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        
        .file-selected {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%) !important;
        }
        
        input[type="number"], input[type="range"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }
        
        input[type="number"]:focus, input[type="range"]:focus {
            outline: none;
            border-color: #4facfe;
        }
        
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .checkbox-wrapper input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .tolerance-display {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #4facfe;
            margin-top: 10px;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa726 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #636e72 0%, #74b9ff 100%);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress-container {
            margin: 20px 0;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #495057;
        }
        
        .results-container {
            margin-top: 30px;
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            font-size: 2.5rem;
            margin-bottom: 5px;
        }
        
        .stat-card p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .results-table {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            max-height: 500px;
            overflow-y: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #f8f9fa;
            transition: background-color 0.2s ease;
        }
        
        tr:hover td {
            background-color: #f8f9fa;
        }
        
        .status-success {
            color: #28a745;
            font-weight: 600;
        }
        
        .status-error {
            color: #dc3545;
            font-weight: 600;
        }
        
        .category-tag {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            display: inline-block;
        }
        
        .category-50 { background: #d4edda; color: #155724; }
        .category-100 { background: #d1ecf1; color: #0c5460; }
        .category-150 { background: #fff3cd; color: #856404; }
        .category-150plus { background: #f8d7da; color: #721c24; }
        
        .log-container {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid #f5c6cb;
        }
        
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid #c3e6cb;
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stat-card h3 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Split Line FDT to FAT via POLE</h1>
            <p>Polyline-Guided Edition - Streaming KMZ Processing up to 10GB</p>
        </div>
        
        <div class="main-content">
            <div class="control-panel">
                <div class="form-group">
                    <label for="kmzFile">Upload KMZ/KML File (Max 10GB, 300K+ items)</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="kmzFile" class="file-input" accept=".kmz,.kml" />
                        <button type="button" class="file-input-button" onclick="document.getElementById('kmzFile').click()">
                            üìÅ Pilih File KMZ/KML
                        </button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="tolerance">Toleransi Jarak ke Polyline/POLE (meter)</label>
                    <input type="range" id="tolerance" min="1" max="10" value="4" oninput="updateToleranceDisplay()">
                    <div class="tolerance-display" id="toleranceDisplay">4 meter</div>
                </div>
                
                <div class="form-group">
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="includePole" checked>
                        <label for="includePole">Harus Melewati POLE</label>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" id="generateBtn" onclick="generateLines()" disabled>
                        üöÄ Generate Split Lines
                    </button>
                    <button class="btn btn-success" id="downloadKMZ" onclick="downloadKMZ()" disabled>
                        üì¶ Download KMZ
                    </button>
                    <button class="btn btn-info" id="downloadKML" onclick="downloadKML()" disabled>
                        üìÑ Download KML
                    </button>
                    <button class="btn btn-secondary" id="downloadCSV" onclick="downloadCSV()" disabled>
                        üìä Download CSV
                    </button>
                    <button class="btn btn-secondary" onclick="refreshApp()">
                        üîÑ Refresh App
                    </button>
                </div>
            </div>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Processing...</div>
            </div>
            
            <div class="results-container" id="resultsContainer">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3 id="totalLinesCount">0</h3>
                        <p>Total Lines Generated</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="successCount">0</h3>
                        <p>Successful Connections</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="avgDistance">0</h3>
                        <p>Average Distance (m)</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="processingTime">0</h3>
                        <p>Processing Time (s)</p>
                    </div>
                </div>
                
                <div class="results-table">
                    <table id="resultsTable">
                        <thead>
                            <tr>
                                <th>FDT</th>
                                <th>FAT</th>
                                <th>POLE Path</th>
                                <th>Distance (m)</th>
                                <th>Category</th>
                                <th>Line Name</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="resultsTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="log-container" id="logContainer">
                <div id="logContent">Ready to process KMZ/KML files...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentData = {
            placemarks: [],
            results: [],
            kmlContent: '',
            startTime: null
        };
        
        let parsedData = {
            FDT: [],
            FAT: [],
            POLE: [],
            POLYLINE: []
        };

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            updateToleranceDisplay();
            setupFileInput();
            log('Application initialized successfully');
        });

        function setupFileInput() {
            const fileInput = document.getElementById('kmzFile');
            const fileButton = document.querySelector('.file-input-button');
            
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const fileSize = (file.size / 1024 / 1024).toFixed(2);
                    
                    fileButton.textContent = `üìÅ ${file.name} (${fileSize} MB)`;
                    fileButton.classList.add('file-selected');
                    document.getElementById('generateBtn').disabled = false;
                    
                    log(`File selected: ${file.name} (${fileSize} MB)`);
                }
            });
        }

        function updateToleranceDisplay() {
            const tolerance = document.getElementById('tolerance').value;
            document.getElementById('toleranceDisplay').textContent = `${tolerance} meter`;
        }

        function log(message) {
            const logContent = document.getElementById('logContent');
            const timestamp = new Date().toLocaleTimeString();
            logContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logContent.scrollTop = logContent.scrollHeight;
        }

        function updateProgress(percent, text = '') {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = `${percent}%`;
            if (text) {
                progressText.textContent = text;
            }
        }

        function showProgress() {
            document.getElementById('progressContainer').style.display = 'block';
            updateProgress(0, 'Initializing...');
        }

        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }

        function showResults() {
            document.getElementById('resultsContainer').style.display = 'block';
            document.getElementById('downloadKMZ').disabled = false;
            document.getElementById('downloadKML').disabled = false;
            document.getElementById('downloadCSV').disabled = false;
        }

        // Haversine distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        function getDistanceToPolyline(point, polylineCoords) {
            let minDistance = Infinity;
            
            for (let i = 0; i < polylineCoords.length - 1; i++) {
                const segmentStart = polylineCoords[i];
                const segmentEnd = polylineCoords[i + 1];
                
                const distance = distanceToLineSegment(point, segmentStart, segmentEnd);
                minDistance = Math.min(minDistance, distance);
            }
            
            return minDistance;
        }

        function distanceToLineSegment(point, lineStart, lineEnd) {
            const A = point[0] - lineStart[0];
            const B = point[1] - lineStart[1];
            const C = lineEnd[0] - lineStart[0];
            const D = lineEnd[1] - lineStart[1];

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) {
                return calculateDistance(point[1], point[0], lineStart[1], lineStart[0]);
            }
            
            let param = dot / lenSq;
            let xx, yy;

            if (param < 0) {
                xx = lineStart[0];
                yy = lineStart[1];
            } else if (param > 1) {
                xx = lineEnd[0];
                yy = lineEnd[1];
            } else {
                xx = lineStart[0] + param * C;
                yy = lineStart[1] + param * D;
            }

            return calculateDistance(point[1], point[0], yy, xx);
        }

        function findNearestPole(point, poles) {
            let nearestPole = null;
            let minDistance = Infinity;
            
            poles.forEach(pole => {
                const distance = calculateDistance(
                    point.coordinates[1], point.coordinates[0],
                    pole.coordinates[1], pole.coordinates[0]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPole = pole;
                }
            });
            
            return { pole: nearestPole, distance: minDistance };
        }

        function findPathInPolyline(polyline, startPole, endPole) {
            const coords = polyline.coordinates;
            const tolerance = parseFloat(document.getElementById('tolerance').value);
            
            let startIndex = -1;
            let endIndex = -1;
            
            // Find start and end indices in polyline
            for (let i = 0; i < coords.length; i++) {
                const coord = coords[i];
                
                if (startIndex === -1) {
                    const distToStart = calculateDistance(
                        coord[1], coord[0],
                        startPole.coordinates[1], startPole.coordinates[0]
                    );
                    if (distToStart <= tolerance) {
                        startIndex = i;
                    }
                }
                
                if (endIndex === -1) {
                    const distToEnd = calculateDistance(
                        coord[1], coord[0],
                        endPole.coordinates[1], endPole.coordinates[0]
                    );
                    if (distToEnd <= tolerance) {
                        endIndex = i;
                    }
                }
            }
            
            if (startIndex === -1 || endIndex === -1) {
                return null;
            }
            
            // Extract path between indices
            const path = [];
            if (startIndex <= endIndex) {
                for (let i = startIndex; i <= endIndex; i++) {
                    path.push(coords[i]);
                }
            } else {
                for (let i = startIndex; i >= endIndex; i--) {
                    path.push(coords[i]);
                }
            }
            
            return path;
        }

        function categorizeDistance(distance) {
            if (distance < 50) return { tag: 'category-50', name: '¬±50m' };
            if (distance < 100) return { tag: 'category-100', name: '¬±100m' };
            if (distance < 150) return { tag: 'category-150', name: '¬±150m' };
            return { tag: 'category-150plus', name: '¬±150m+' };
        }

        function escapeXml(text) {
            if (typeof text !== 'string') return text;
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;');
        }

        async function generateLines() {
            const fileInput = document.getElementById('kmzFile');
            if (!fileInput.files.length) {
                log('‚ùå Please select a KMZ/KML file first');
                return;
            }

            const file = fileInput.files[0];
            const tolerance = parseFloat(document.getElementById('tolerance').value);
            const includePole = document.getElementById('includePole').checked;
            
            showProgress();
            currentData.startTime = performance.now();
            
            try {
                log(`üöÄ Starting processing of ${file.name}`);
                updateProgress(10, 'Reading file...');
                
                // Read file
                let kmlContent;
                if (file.name.toLowerCase().endsWith('.kmz')) {
                    const zip = new JSZip();
                    const zipContent = await zip.loadAsync(file);
                    const kmlFile = zipContent.file(/\.kml$/i)[0];
                    if (!kmlFile) {
                        throw new Error('No KML file found in KMZ');
                    }
                    kmlContent = await kmlFile.async('string');
                } else {
                    kmlContent = await file.text();
                }
                
                updateProgress(30, 'Parsing KML content...');
                log('üìñ Parsing KML content...');
                
                // Parse KML
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlContent, 'text/xml');
                
                if (kmlDoc.querySelector('parsererror')) {
                    throw new Error('Invalid XML/KML format');
                }
                
                // Extract placemarks
                const placemarks = kmlDoc.querySelectorAll('Placemark');
                log(`üîç Found ${placemarks.length} placemarks`);
                
                updateProgress(50, 'Categorizing placemarks...');
                
                // Reset parsed data
                parsedData = { FDT: [], FAT: [], POLE: [], POLYLINE: [] };
                
                // Categorize placemarks
                Array.from(placemarks).forEach((placemark, index) => {
                    if (index % 1000 === 0) {
                        updateProgress(50 + (index / placemarks.length) * 20, 
                            `Processing placemark ${index + 1}/${placemarks.length}`);
                    }
                    
                    const name = placemark.querySelector('name')?.textContent || '';
                    const coordinates = extractCoordinates(placemark);
                    
                    if (!coordinates) return;
                    
                    const item = {
                        name: name,
                        coordinates: coordinates.coords,
                        type: coordinates.type
                    };
                    
                    if (name.toUpperCase().includes('FDT')) {
                        parsedData.FDT.push(item);
                    } else if (name.toUpperCase().includes('FAT')) {
                        parsedData.FAT.push(item);
                    } else if (name.toUpperCase().includes('POLE')) {
                        parsedData.POLE.push(item);
                    } else if (coordinates.type === 'LineString') {
                        parsedData.POLYLINE.push(item);
                    }
                });
                
                log(`üìä Categorized: FDT=${parsedData.FDT.length}, FAT=${parsedData.FAT.length}, POLE=${parsedData.POLE.length}, POLYLINE=${parsedData.POLYLINE.length}`);
                
                updateProgress(70, 'Generating connections...');
                
                // Generate connections
                const results = [];
                let processed = 0;
                
                for (const polyline of parsedData.POLYLINE) {
                    // Find FDT and FAT within tolerance to this polyline
                    const nearbyFDT = parsedData.FDT.filter(fdt => {
                        const distance = getDistanceToPolyline(fdt.coordinates, polyline.coordinates);
                        return distance <= tolerance;
                    });
                    
                    const nearbyFAT = parsedData.FAT.filter(fat => {
                        const distance = getDistanceToPolyline(fat.coordinates, polyline.coordinates);
                        return distance <= tolerance;
                    });
                    
                    // Process each FDT-FAT combination for this polyline
                    for (const fdt of nearbyFDT) {
                        for (const fat of nearbyFAT) {
                            processed++;
                            
                            if (processed % 100 === 0) {
                                updateProgress(70 + (processed / (nearbyFDT.length * nearbyFAT.length * parsedData.POLYLINE.length)) * 20, 
                                    `Processing connection ${processed}...`);
                            }
                            
                            try {
                                // Find nearest poles
                                const fdtPole = findNearestPole(fdt, parsedData.POLE);
                                const fatPole = findNearestPole(fat, parsedData.POLE);
                                
                                if (!fdtPole.pole || !fatPole.pole) {
                                    results.push({
                                        fdt: fdt.name,
                                        fat: fat.name,
                                        polePath: 'No POLE found',
                                        distance: 0,
                                        category: 'N/A',
                                        lineName: 'N/A',
                                        status: 'Error: No POLE'
                                    });
                                    continue;
                                }
                                
                                // Check pole distance tolerance
                                if (fdtPole.distance > tolerance || fatPole.distance > tolerance) {
                                    results.push({
                                        fdt: fdt.name,
                                        fat: fat.name,
                                        polePath: 'POLE too far',
                                        distance: 0,
                                        category: 'N/A',
                                        lineName: 'N/A',
                                        status: 'Error: POLE distance'
                                    });
                                    continue;
                                }
                                
                                // Find path in polyline
                                const path = findPathInPolyline(polyline, fdtPole.pole, fatPole.pole);
                                
                                if (!path) {
                                    results.push({
                                        fdt: fdt.name,
                                        fat: fat.name,
                                        polePath: 'No valid path',
                                        distance: 0,
                                        category: 'N/A',
                                        lineName: 'N/A',
                                        status: 'Error: No path'
                                    });
                                    continue;
                                }
                                
                                // Calculate total distance
                                let totalDistance = 0;
                                const fullPath = [fdt.coordinates, ...path, fat.coordinates];
                                
                                for (let i = 0; i < fullPath.length - 1; i++) {
                                    const dist = calculateDistance(
                                        fullPath[i][1], fullPath[i][0],
                                        fullPath[i + 1][1], fullPath[i + 1][0]
                                    );
                                    totalDistance += dist;
                                }
                                
                                // Categorize and create line name
                                const category = categorizeDistance(totalDistance);
                                const lineName = `line ${category.name} - (${Math.round(totalDistance)} meter)`;
                                
                                // Create POLE path string
                                const poleNames = [fdtPole.pole.name, fatPole.pole.name];
                                const polePathStr = poleNames.join(' ‚Üí ');
                                
                                results.push({
                                    fdt: fdt.name,
                                    fat: fat.name,
                                    polePath: polePathStr,
                                    distance: Math.round(totalDistance),
                                    category: category.name,
                                    categoryTag: category.tag,
                                    lineName: lineName,
                                    status: 'Success',
                                    coordinates: fullPath
                                });
                                
                            } catch (error) {
                                results.push({
                                    fdt: fdt.name,
                                    fat: fat.name,
                                    polePath: 'Processing error',
                                    distance: 0,
                                    category: 'N/A',
                                    lineName: 'N/A',
                                    status: `Error: ${error.message}`
                                });
                            }
                        }
                    }
                }
                
                currentData.results = results;
                
                updateProgress(90, 'Finalizing results...');
                
                // Generate KML content for export
                currentData.kmlContent = generateKMLContent(results);
                
                updateProgress(100, 'Processing complete!');
                
                const endTime = performance.now();
                const processingTime = ((endTime - currentData.startTime) / 1000).toFixed(2);
                
                log(`‚úÖ Processing completed in ${processingTime} seconds`);
                log(`üìà Generated ${results.length} connections`);
                
                // Update statistics
                const successResults = results.filter(r => r.status === 'Success');
                const avgDistance = successResults.length > 0 
                    ? Math.round(successResults.reduce((sum, r) => sum + r.distance, 0) / successResults.length)
                    : 0;
                
                document.getElementById('totalLinesCount').textContent = results.length;
                document.getElementById('successCount').textContent = successResults.length;
                document.getElementById('avgDistance').textContent = avgDistance;
                document.getElementById('processingTime').textContent = processingTime;
                
                // Populate results table
                populateResultsTable(results);
                
                hideProgress();
                showResults();
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                hideProgress();
                
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = `Error processing file: ${error.message}`;
                document.querySelector('.control-panel').appendChild(errorDiv);
                
                setTimeout(() => errorDiv.remove(), 5000);
            }
        }

        function extractCoordinates(placemark) {
            const point = placemark.querySelector('Point coordinates');
            if (point) {
                const coords = point.textContent.trim().split(',');
                return {
                    coords: [parseFloat(coords[0]), parseFloat(coords[1])],
                    type: 'Point'
                };
            }
            
            const lineString = placemark.querySelector('LineString coordinates');
            if (lineString) {
                const coordText = lineString.textContent.trim();
                const coords = coordText.split(/\s+/).map(coord => {
                    const parts = coord.split(',');
                    return [parseFloat(parts[0]), parseFloat(parts[1])];
                }).filter(coord => !isNaN(coord[0]) && !isNaN(coord[1]));
                
                return {
                    coords: coords,
                    type: 'LineString'
                };
            }
            
            return null;
        }

        function populateResultsTable(results) {
            const tbody = document.getElementById('resultsTableBody');
            tbody.innerHTML = '';
            
            results.forEach(result => {
                const row = document.createElement('tr');
                
                const statusClass = result.status === 'Success' ? 'status-success' : 'status-error';
                const categoryTag = result.categoryTag ? `<span class="category-tag ${result.categoryTag}">${result.category}</span>` : result.category;
                
                row.innerHTML = `
                    <td>${escapeXml(result.fdt)}</td>
                    <td>${escapeXml(result.fat)}</td>
                    <td>${escapeXml(result.polePath)}</td>
                    <td>${result.distance}</td>
                    <td>${categoryTag}</td>
                    <td>${escapeXml(result.lineName)}</td>
                    <td><span class="${statusClass}">${result.status}</span></td>
                `;
                
                tbody.appendChild(row);
            });
        }

        function generateKMLContent(results) {
            const successResults = results.filter(r => r.status === 'Success' && r.coordinates);
            
            let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Split Lines FDT to FAT via POLE</name>
    <description>Generated split lines from FDT to FAT via POLE using polyline guidance</description>
    
    <!-- Styles for different categories -->
    <Style id="style50">
      <LineStyle>
        <color>ff00ff00</color>
        <width>3</width>
      </LineStyle>
    </Style>
    
    <Style id="style100">
      <LineStyle>
        <color>ff00ffff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    
    <Style id="style150">
      <LineStyle>
        <color>ff0080ff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    
    <Style id="style150plus">
      <LineStyle>
        <color>ff0000ff</color>
        <width>3</width>
      </LineStyle>
    </Style>
    
`;

            successResults.forEach((result, index) => {
                const styleId = result.category.includes('50') ? 'style50' :
                               result.category.includes('100') ? 'style100' :
                               result.category.includes('150+') ? 'style150plus' : 'style150';
                
                const coordinatesStr = result.coordinates
                    .map(coord => `${coord[0]},${coord[1]},0`)
                    .join(' ');
                
                kmlContent += `    <Placemark>
      <name>${escapeXml(result.lineName)}</name>
      <description>
        FDT: ${escapeXml(result.fdt)}
        FAT: ${escapeXml(result.fat)}
        POLE Path: ${escapeXml(result.polePath)}
        Distance: ${result.distance} meters
        Category: ${result.category}
      </description>
      <styleUrl>#${styleId}</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>${coordinatesStr}</coordinates>
      </LineString>
    </Placemark>
    
`;
            });
            
            kmlContent += `  </Document>
</kml>`;
            
            return kmlContent;
        }

        async function downloadKMZ() {
            if (!currentData.kmlContent) {
                log('‚ùå No KML content available for download');
                return;
            }
            
            try {
                const zip = new JSZip();
                zip.file('doc.kml', currentData.kmlContent);
                
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob);
                link.download = `split_lines_${new Date().getTime()}.kmz`;
                link.click();
                
                URL.revokeObjectURL(link.href);
                log('üì¶ KMZ file downloaded successfully');
                
            } catch (error) {
                log(`‚ùå Error creating KMZ: ${error.message}`);
            }
        }

        function downloadKML() {
            if (!currentData.kmlContent) {
                log('‚ùå No KML content available for download');
                return;
            }
            
            const blob = new Blob([currentData.kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `split_lines_${new Date().getTime()}.kml`;
            link.click();
            
            URL.revokeObjectURL(link.href);
            log('üìÑ KML file downloaded successfully');
        }

        function downloadCSV() {
            if (!currentData.results.length) {
                log('‚ùå No results available for CSV download');
                return;
            }
            
            const headers = ['FDT', 'FAT', 'POLE Path', 'Distance (m)', 'Category', 'Line Name', 'Status'];
            let csvContent = headers.join(',') + '\n';
            
            currentData.results.forEach(result => {
                const row = [
                    `"${result.fdt.replace(/"/g, '""')}"`,
                    `"${result.fat.replace(/"/g, '""')}"`,
                    `"${result.polePath.replace(/"/g, '""')}"`,
                    result.distance,
                    `"${result.category}"`,
                    `"${result.lineName.replace(/"/g, '""')}"`,
                    `"${result.status.replace(/"/g, '""')}"`
                ];
                csvContent += row.join(',') + '\n';
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `split_lines_results_${new Date().getTime()}.csv`;
            link.click();
            
            URL.revokeObjectURL(link.href);
            log('üìä CSV file downloaded successfully');
        }

        function refreshApp() {
            // Reset all data
            currentData = {
                placemarks: [],
                results: [],
                kmlContent: '',
                startTime: null
            };
            
            parsedData = {
                FDT: [],
                FAT: [],
                POLE: [],
                POLYLINE: []
            };
            
            // Reset UI
            document.getElementById('kmzFile').value = '';
            document.querySelector('.file-input-button').textContent = 'üìÅ Pilih File KMZ/KML';
            document.querySelector('.file-input-button').classList.remove('file-selected');
            
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('downloadKMZ').disabled = true;
            document.getElementById('downloadKML').disabled = true;
            document.getElementById('downloadCSV').disabled = true;
            
            document.getElementById('resultsContainer').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'none';
            
            // Reset stats
            document.getElementById('totalLinesCount').textContent = '0';
            document.getElementById('successCount').textContent = '0';
            document.getElementById('avgDistance').textContent = '0';
            document.getElementById('processingTime').textContent = '0';
            
            // Clear table
            document.getElementById('resultsTableBody').innerHTML = '';
            
            // Clear log
            document.getElementById('logContent').innerHTML = 'Application refreshed. Ready to process KMZ/KML files...';
            
            // Remove any error messages
            document.querySelectorAll('.error-message, .success-message').forEach(el => el.remove());
            
            log('üîÑ Application refreshed successfully');
        }

        // Performance monitoring
        function logMemoryUsage() {
            if (performance.memory) {
                const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                const total = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
                log(`üíæ Memory: ${used}MB / ${total}MB`);
            }
        }

        // Auto-refresh memory logging during processing
        setInterval(() => {
            if (document.getElementById('progressContainer').style.display === 'block') {
                logMemoryUsage();
            }
        }, 10000);
        
    </script>
</body>
</html>
