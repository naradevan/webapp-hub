<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMZ Style xsanosaurus</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
      window.addEventListener('load', function() {
        var script = document.createElement('script');
        script.async = true;
        script.src = 'https://www.googletagmanager.com/gtag/js?id=G-T12DERDD3M';
        document.head.appendChild(script);
        
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-T12DERDD3M');
      });
    </script>
    
    <style>
        /* --- MAIN STYLES --- */
        :root { --bg-body: #0d0d0d; --bg-surface: #171717; --bg-surface-hover: #222; --border: #333; --primary: #3b82f6; --primary-hover: #2563eb; --text-main: #ededed; --text-muted: #888; --success: #22c55e; --error: #ef4444; --radius: 8px; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: var(--bg-body); color: var(--text-main); line-height: 1.5; min-height: 100vh; display: flex; justify-content: center; padding-top: 5vh; }
        .container { width: 100%; max-width: 680px; padding: 0 1.5rem; }
        header { margin-bottom: 2rem; text-align: center; }
        h1 { font-size: 1.75rem; font-weight: 600; letter-spacing: -0.03em; margin-bottom: 0.5rem; background: linear-gradient(to bottom right, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-muted); font-size: 0.95rem; }
        .card { background: var(--bg-surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 2rem; margin-bottom: 1.5rem; box-shadow: 0 10px 30px -10px rgba(0,0,0,0.5); }
        .mode-selector { display: flex; background: #222; padding: 4px; border-radius: 8px; margin-bottom: 1.5rem; }
        .mode-option { flex: 1; text-align: center; padding: 10px; cursor: pointer; font-size: 0.9rem; font-weight: 600; color: var(--text-muted); border-radius: 6px; transition: all 0.2s; }
        .mode-option.active { color: #fff; background: var(--primary); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .file-drop-area { border: 2px dashed var(--border); border-radius: var(--radius); height: 140px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; background: rgba(255,255,255,0.01); margin-bottom: 1.5rem; color: var(--text-muted); }
        .file-drop-area:hover { border-color: var(--primary); background: rgba(59, 130, 246, 0.05); color: var(--text-main); }
        .file-drop-area.active { border-color: var(--success); background: rgba(34, 197, 94, 0.05); }
        #fileLabel { font-size: 0.95rem; pointer-events: none; transition: color 0.2s; }
        input[type="file"] { display: none; }
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-direction: column; }
        .row-btn { display: flex; gap: 10px; justify-content: center; }
        button { padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 0.9rem; font-weight: 500; cursor: pointer; transition: all 0.2s; border: none; }
        button.primary { background: var(--primary); color: white; box-shadow: 0 2px 10px rgba(59, 130, 246, 0.2); }
        button.primary:hover:not(:disabled) { background: var(--primary-hover); transform: translateY(-1px); }
        button.primary:disabled { background: var(--bg-surface-hover); color: var(--text-muted); cursor: not-allowed; box-shadow: none; }
        button.secondary { background: transparent; border: 1px solid var(--border); color: var(--text-main); }
        button.secondary:hover { border-color: var(--text-muted); background: var(--bg-surface-hover); }
        button.success { background: var(--success); color: white; margin-top: 10px; }
        button.success:hover { filter: brightness(1.1); }
        #status { margin-top: 1.5rem; font-size: 0.9rem; text-align: center; min-height: 24px; }
        .folder-list { background: #111; border: 1px solid var(--border); border-radius: var(--radius); padding: 1rem; max-height: 400px; overflow-y: auto; font-family: 'Menlo', 'Monaco', 'Courier New', monospace; font-size: 0.85rem; }
        .tree-item { margin-left: 1.5rem; border-left: 1px solid #333; padding-left: 0.75rem; margin-bottom: 0.25rem; position: relative; }
        .tree-folder { color: #fbbf24; font-weight: 600; }
        .tree-subfolder { color: #4ade80; }
        .tree-info { color: #666; font-size: 0.8em; margin-left: 0.5rem; }
        .hidden { display: none; }
        .loading-spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: #fff; animation: spin 0.8s linear infinite; margin-right: 8px; vertical-align: text-bottom; }
        @keyframes spin { to { transform: rotate(360deg); } }
        ::-webkit-scrollbar { width: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

        /* --- README MODAL STYLES --- */
        .top-right-btn { position: absolute; top: 1.5rem; right: 1.5rem; z-index: 100; }
        .btn-readme { background: transparent; border: 1px solid var(--border); color: var(--text-muted); padding: 8px 16px; border-radius: 20px; font-size: 0.85rem; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .btn-readme:hover { border-color: var(--primary); color: var(--text-main); background: rgba(59, 130, 246, 0.1); }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: all 0.3s ease; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        
        .modal-box { background: var(--bg-surface); border: 1px solid var(--border); border-radius: var(--radius); width: 90%; max-width: 800px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 20px 50px rgba(0,0,0,0.5); transform: translateY(20px); transition: transform 0.3s ease; }
        .modal-overlay.open .modal-box { transform: translateY(0); }
        
        .modal-header { padding: 1.5rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: #111; border-radius: var(--radius) var(--radius) 0 0; }
        .modal-header h2 { font-size: 1.2rem; margin: 0; color: var(--text-main); }
        
        .close-modal { background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; padding: 0; line-height: 1; }
        .close-modal:hover { color: var(--error); }
        
        .modal-body { padding: 2rem; overflow-y: auto; font-size: 0.95rem; line-height: 1.6; color: #ccc; }
        .modal-body::-webkit-scrollbar { width: 8px; }
        .modal-body::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        .modal-body::-webkit-scrollbar-track { background: #111; }

        /* Styles khusus untuk konten Markdown yang dirender */
        .md-content h1, .md-content h2 { color: var(--text-main); margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 1px solid #333; padding-bottom: 0.5rem; }
        .md-content h3 { color: var(--primary); margin-top: 1.5rem; margin-bottom: 0.75rem; }
        .md-content ul, .md-content ol { padding-left: 1.5rem; margin-bottom: 1rem; }
        .md-content li { margin-bottom: 0.5rem; }
        .md-content code { background: #222; padding: 2px 6px; border-radius: 4px; color: #fbbf24; font-family: monospace; border: 1px solid #333; }
        .md-content pre { background: #111; padding: 1rem; border-radius: 6px; border: 1px solid #333; overflow-x: auto; margin-bottom: 1rem; }
        .md-content pre code { background: transparent; padding: 0; border: none; color: #ccc; }
        .md-content blockquote { border-left: 3px solid var(--primary); background: rgba(59, 130, 246, 0.1); padding: 1rem; margin: 1rem 0; border-radius: 0 6px 6px 0; }
        .md-content table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        .md-content th, .md-content td { border: 1px solid #444; padding: 10px; text-align: left; }
        .md-content th { background: #222; color: #fff; font-weight: 600; }
        .md-content tr:nth-child(even) { background: #1a1a1a; }
        .md-content a { color: var(--primary); text-decoration: none; }
        .md-content a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <div class="top-right-btn">
        <button class="btn-readme" onclick="openReadme()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            Readme / Help
        </button>
    </div>

    <div id="readmeModal" class="modal-overlay" onclick="if(event.target === this) toggleModal(false)">
        <div class="modal-box">
            <div class="modal-header">
                <h2>Dokumentasi & Rules</h2>
                <button class="close-modal" onclick="toggleModal(false)">×</button>
            </div>
            <div class="modal-body md-content" id="mdContainer">
                <div style="text-align:center; padding: 2rem; color: #888;">
                    <span class="loading-spinner"></span> Loading documentation...
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>KMZ Style EMR by xsanosaurus</h1>
            <p class="subtitle">Update: 04-01-2026 16:09:45</p>
        </header>

        <div class="card">
            <div class="mode-selector">
                <div class="mode-option active" onclick="setMode('cluster')" id="btn-cluster">CLUSTER MODE</div>
                <div class="mode-option" onclick="setMode('subfeeder')" id="btn-subfeeder">SUBFEEDER MODE</div>
            </div>

            <label class="file-drop-area" id="dropArea">
                <span id="fileLabel">Drag & drop KMZ/KML here or click to upload</span>
                <input type="file" id="kmzFile" accept=".kmz, .kml" />
            </label>

            <div class="btn-group">
                <div class="row-btn">
                    <button id="processBtn" class="primary" disabled>Process File</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>
            </div>
            
            <div id="status"></div>
        </div>

        <div id="preview" class="hidden">
            <div class="card" style="padding: 1rem;">
                <h3 style="font-size: 0.9rem; margin-bottom: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Structure Preview</h3>
                <div class="folder-list" id="folderList"></div>
            </div>
        </div>
    </div>

    <script>
        // --- README LOADER LOGIC ---
        let readmeLoaded = false;

        async function openReadme() {
            toggleModal(true);
            
            // Cek apakah sudah pernah diload agar tidak fetch berulang kali
            if (readmeLoaded) return;

            const container = document.getElementById('mdContainer');
            
            try {
                // Fetch file README.md yang ada di folder yang sama
                const response = await fetch('README.md');
                
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status}`);
                }

                const markdownText = await response.text();
                
                // Gunakan Marked.js untuk convert Markdown ke HTML
                container.innerHTML = marked.parse(markdownText);
                readmeLoaded = true;

            } catch (error) {
                console.error("Gagal load README:", error);
                container.innerHTML = `
                    <div style="text-align:center; color: var(--error); padding: 20px;">
                        <p><strong>Gagal memuat dokumentasi.</strong></p>
                        <p style="font-size:0.9em; color:#888;">Pastikan file <code>README.md</code> ada di folder yang sama dengan file ini.</p>
                        <p style="font-size:0.8em; margin-top:10px;">Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        function toggleModal(show) {
            const modal = document.getElementById('readmeModal');
            if (show) {
                modal.classList.add('open');
                document.body.style.overflow = 'hidden'; 
            } else {
                modal.classList.remove('open');
                document.body.style.overflow = '';
            }
        }
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') toggleModal(false);
        });

        // --- CONFIGURATION ---
        let CURRENT_MODE = 'cluster'; 
        const TEXT_SIZE = 1.0; 
        const SNAP_TOLERANCE_METERS = 15; 

        // --- CLUSTER STRUCTURE ---
        const STRUCTURE_CLUSTER = [
            'BOUNDARY FAT', 'FAT', 'HP COVER', 'HP UNCOVER',
            'EXISTING POLE EMR 7-2.5', 'EXISTING POLE EMR 7-3', 'EXISTING POLE EMR 7-4', 'EXISTING POLE EMR 9-4',
            'EXISTING POLE PARTNER 7-4', 'EXISTING POLE PARTNER 9-4',
            'NEW POLE 7-2.5', 'NEW POLE 7-3', 'NEW POLE 7-4', 'NEW POLE 9-4',
            'DISTRIBUTION CABLE', 'SLACK HANGER', 'SLING WIRE'
        ];

        const RULES_CLUSTER = [
            { folder: '-', placemark: '288C', line: '-', polygon: '-', colorCode: '#AA0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '144C', line: '-', polygon: '-', colorCode: '#FFFF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '96C', line: '-', polygon: '-', colorCode: '#00FFFF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '72C', line: '-', polygon: '-', colorCode: '#0000FF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '48C', line: '-', polygon: '-', colorCode: '#AA00FF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: 'BOUNDARY FAT', placemark: '-', line: '-', polygon: '-', colorCode: '#009999', styleLink: '-' },
            { folder: 'FAT', placemark: '-', line: '-', polygon: '-', colorCode: '#FFFF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/triangle.png' },
            { folder: 'HP COVER', placemark: '-', line: '-', polygon: '-', colorCode: '#00FF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/homegardenbusiness.png' },
            { folder: 'HP UNCOVER', placemark: '-', line: '-', polygon: '-', colorCode: '#ff0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/homegardenbusiness.png' },
            { folder: 'NEW POLE 9-4', placemark: 'NEW POLE 9-4', line: '-', polygon: '-', colorCode: '#FF0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'NEW POLE 7-4', placemark: 'NEW POLE 7-4', line: '-', polygon: '-', colorCode: '#00FF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'NEW POLE 7-3', placemark: 'NEW POLE 7-3', line: '-', polygon: '-', colorCode: '#00FFFF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'NEW POLE 7-2.5', placemark: 'NEW POLE 7-2.5', line: '-', polygon: '-', colorCode: '#AA00FF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 7-2.5', placemark: 'EXISTING POLE EMR 7-2.5', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 7-3', placemark: 'EXISTING POLE EMR 7-3', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 7-4', placemark: 'EXISTING POLE EMR 7-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 9-4', placemark: 'EXISTING POLE EMR 9-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE PARTNER 7-4', placemark: 'EXISTING POLE PARTNER 7-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE PARTNER 9-4', placemark: 'EXISTING POLE PARTNER 9-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '24C', polygon: '-', colorCode: '#00FF00', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '36C', polygon: '-', colorCode: '#FF00FF', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '48C', polygon: '-', colorCode: '#AA00FF', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '72C', polygon: '-', colorCode: '#550000', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '96C', polygon: '-', colorCode: '#FF0000', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '144C', polygon: '-', colorCode: '#FFFF00', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '288C', polygon: '-', colorCode: '#FFAA00', styleLink: '-' },
            { folder: 'SLING WIRE', placemark: '-', line: '-', polygon: '-', colorCode: '#00FFFF', styleLink: '-' },
            { folder: 'FDT', placemark: 'FDT', line: '-', polygon: '-', colorCode: '#AA0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: 'SLACK HANGER', placemark: 'SLACK', line: '-', polygon: '-', colorCode: '#ff0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/target.png' }
        ];

        const STRUCTURE_SUBFEEDER = [
            'JOINT CLOSURE', 'EXISTING POLE EMR 7-2.5', 'EXISTING POLE EMR 7-3', 'EXISTING POLE EMR 7-4', 
            'EXISTING POLE EMR 7-5', 'EXISTING POLE EMR 9-5', 'EXISTING POLE EMR 9-4', 
            'EXISTING POLE PARTNER 7-4', 'EXISTING POLE PARTNER 9-4', 'NEW POLE 7-5', 'NEW POLE 9-5', 
            'NEW POLE 7-4', 'NEW POLE 9-4', 'CABLE', 'SLACK HANGER'
        ];
        
        const RULES_SUBFEEDER = [
            { folder: 'SLACK HANGER', placemark: 'SLACK', line: '-', polygon: '-', colorCode: '#ff0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/target.png' }
        ];

        let kmzFile = null;
        let processedKMZ = null;
        let processedHPDB = null;

        const kmzInput = document.getElementById('kmzFile');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        const fileLabel = document.getElementById('fileLabel');
        const dropArea = document.getElementById('dropArea');

        function setMode(mode) {
            CURRENT_MODE = mode;
            document.querySelectorAll('.mode-option').forEach(el => el.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
        }

        dropArea.addEventListener('dragover', (e) => { e.preventDefault(); dropArea.classList.add('active'); });
        dropArea.addEventListener('dragleave', () => dropArea.classList.remove('active'));
        dropArea.addEventListener('drop', (e) => { e.preventDefault(); dropArea.classList.remove('active'); if(e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });
        kmzInput.addEventListener('change', (e) => { if (e.target.files.length) handleFile(e.target.files[0]); });

        function handleFile(file) {
            if(!file.name.toLowerCase().endsWith('.kmz') && !file.name.toLowerCase().endsWith('.kml')) { alert('File harus .KMZ atau .KML'); return; }
            kmzFile = file;
            fileLabel.textContent = `${file.name} (${(file.size/1024).toFixed(1)} KB)`;
            fileLabel.style.color = 'var(--primary)';
            processBtn.disabled = false;
        }

        processBtn.addEventListener('click', async () => {
            if (!kmzFile) return;
            processBtn.disabled = true;
            statusDiv.innerHTML = '<span class="loading-spinner"></span>Processing...';

            try {
                let xmlDoc;
                if (kmzFile.name.toLowerCase().endsWith('.kmz')) {
                    const zip = new JSZip();
                    const contents = await zip.loadAsync(kmzFile);
                    const kmlName = Object.keys(contents.files).find(n => n.endsWith('.kml'));
                    const kmlString = await contents.files[kmlName].async('string');
                    xmlDoc = new DOMParser().parseFromString(kmlString, 'text/xml');
                } else {
                    const kmlString = await kmzFile.text();
                    xmlDoc = new DOMParser().parseFromString(kmlString, 'text/xml');
                }

                // 1. Restructure
                const tree = restructureKML(xmlDoc);
                
                if (CURRENT_MODE === 'cluster') {
                    // 2. Spatial Grouping HP (V31)
                    organizeHpByBoundary(xmlDoc);
                    // 3. Auto Reposition (V30)
                    autoRepositionPoints(xmlDoc);
                }

                // 4. Apply Styling
                applyStyles(xmlDoc);
                // 5. Inject Descriptions & Calc
                injectDescriptionsAndCalc(xmlDoc);
                // 6. Display Tree
                displayTree(tree);

                // 7. Generate HPDB CSV (V36 Fix: Support ALL Lines)
                if (CURRENT_MODE === 'cluster') {
                    processedHPDB = generateHPDB(xmlDoc);
                }

                const serializer = new XMLSerializer();
                const newKml = serializer.serializeToString(xmlDoc);
                const zipOut = new JSZip();
                zipOut.file("doc.kml", newKml);
                processedKMZ = await zipOut.generateAsync({ type: 'blob' });

                statusDiv.innerHTML = '<span style="color:var(--success)">✅ Done!</span>';
                
                const dlBtn = document.createElement('button');
                dlBtn.className = 'success';
                dlBtn.textContent = `Download KMZ Result`;
                dlBtn.onclick = () => {
                    const url = URL.createObjectURL(processedKMZ);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `STYLED_${CURRENT_MODE.toUpperCase()}_${kmzFile.name.replace(/\.kml$/i, '.kmz')}`;
                    a.click();
                };

                const btnGroup = document.querySelector('.btn-group');
                const oldBtns = btnGroup.querySelectorAll('.success');
                oldBtns.forEach(b => b.remove());
                btnGroup.appendChild(dlBtn);

                if (processedHPDB) {
                    const csvBtn = document.createElement('button');
                    csvBtn.className = 'success';
                    csvBtn.style.background = '#8b5cf6';
                    csvBtn.textContent = `Download HPDB Result (CSV)`;
                    csvBtn.onclick = () => {
                        const blob = new Blob([processedHPDB], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `HPDB_${kmzFile.name.replace(/\.k?mz|\.kml/i, '')}.csv`;
                        a.click();
                    };
                    btnGroup.appendChild(csvBtn);
                }

            } catch (err) {
                statusDiv.innerHTML = `<span style="color:var(--error)">Error: ${err.message}</span>`;
                console.error(err);
            } finally {
                processBtn.disabled = false;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => location.reload());

        // --- HPDB GENERATOR (V36 - MULTI LINE SUPPORT) ---

        function generateHPDB(xmlDoc) {
            const headers = [
                'Pole ID', 'Pole Latitude', 'Pole Longitude', 'FAT Address', 'Province', 
                'regency_city', 'district', 'subdistrict', 'postalcode', 'Roll_Out_ID', 
                'acquisition_class', 'acquisition_tier', 'competition', 'project_id', 'Area', 
                'Complex_name', 'Clustername', 'Commercial_name', 'Rw', 'Rt', 'address_prefix', 
                'street', 'address_suffix', 'sub_address_prefix', 'sub_address', 'sub_address_suffix', 
                'block', 'homenumber', 'dwelling_type', 'building_type', 'building_property_name', 
                'building_property_location', 'floor', 'unit', 'homepass_source', 'oltcode', 
                'fdtcode', 'fatcode', 'RFSDate', 'Latitude_homepass', 'Longitude_homepass', 'residential_service_ready'
            ];
            
            let csvContent = headers.join(',') + '\n';

            // 1. Gather ALL resources regardless of LINE folder (Flattening the search space)
            const allFolders = Array.from(xmlDoc.querySelectorAll('Folder'));
            
            // Collect ALL Pole Folders
            const poleFolders = allFolders.filter(f => {
                const n = f.querySelector('name')?.textContent.trim().toUpperCase() || '';
                return n.includes('POLE') || n.includes('TIANG');
            });
            const polePoints = [];
            poleFolders.forEach(pf => {
                pf.querySelectorAll('Placemark').forEach(pm => {
                    const pt = pm.querySelector('Point coordinates');
                    if(pt) {
                        const name = pm.querySelector('name')?.textContent.trim() || 'Unknown';
                        const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                        polePoints.push({ name, lon, lat });
                    }
                });
            });

            // Collect ALL FAT Folders
            const fatFolders = allFolders.filter(f => f.querySelector('name')?.textContent.trim().toUpperCase() === 'FAT');
            const fatPoints = [];
            fatFolders.forEach(ff => {
                ff.querySelectorAll('Placemark').forEach(pm => {
                    const pt = pm.querySelector('Point coordinates');
                    if(pt) {
                        const name = pm.querySelector('name')?.textContent.trim() || 'FAT';
                        const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                        fatPoints.push({ name, lon, lat });
                    }
                });
            });

            // Collect ALL HP COVER Folders
            const hpFolders = allFolders.filter(f => f.querySelector('name')?.textContent.trim().toUpperCase() === 'HP COVER');

            // 2. Iterate Through ALL Found HP COVER Folders (Line A, Line B, etc.)
            hpFolders.forEach(hpFolder => {
                // Get subfolders (Clusters like A01, B01) inside this HP folder
                const subFolders = Array.from(hpFolder.querySelectorAll('Folder'))
                    .sort((a, b) => {
                        const na = a.querySelector('name').textContent;
                        const nb = b.querySelector('name').textContent;
                        return na.localeCompare(nb, undefined, {numeric: true, sensitivity: 'base'});
                    });

                subFolders.forEach(sub => {
                    const subName = sub.querySelector('name').textContent.trim(); // e.g., "A01"
                    const fatCode = subName.slice(-3); // e.g., "A01"

                    // A. Find Anchor FAT (By Name Matching)
                    let anchorFat = fatPoints.find(f => f.name.toUpperCase().includes(fatCode.toUpperCase()));
                    
                    // B. Find Anchor Pole (Strict Coordinate Match first)
                    let anchorPole = { name: '', lon: '', lat: '' };
                    if (anchorFat && polePoints.length > 0) {
                        const exactMatch = polePoints.find(p => haversine(p, anchorFat) < 0.5);
                        if (exactMatch) {
                            anchorPole = exactMatch;
                        } else {
                            anchorPole = polePoints.sort((a, b) => haversine(a, anchorFat) - haversine(b, anchorFat))[0];
                        }
                    }

                    // C. Process HPs
                    sub.querySelectorAll('Placemark').forEach(hp => {
                        const pt = hp.querySelector('Point coordinates');
                        if (pt) {
                            const hpName = hp.querySelector('name')?.textContent.trim() || '';
                            const [hpLon, hpLat] = pt.textContent.trim().split(',').map(Number);

                            const row = [
                                `"${anchorPole.name}"`, 
                                anchorPole.lat,
                                anchorPole.lon,
                                '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 
                                'JLN.', 
                                '', '', '', '', '', '', 
                                `"${hpName}"`, 
                                '', '', '', '', '', '', '',
                                '', 
                                '', 
                                `"${fatCode}"`, 
                                '',
                                hpLat,
                                hpLon,
                                ''
                            ];
                            csvContent += row.join(',') + '\n';
                        }
                    });
                });
            });

            return csvContent;
        }

        // --- SPATIAL UTILS ---
        function toRad(val) { return val * Math.PI / 180; }
        function haversine(pt1, pt2) {
            const R = 6371000; 
            const dLat = toRad(pt2.lat - pt1.lat);
            const dLon = toRad(pt2.lon - pt1.lon);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(pt1.lat)) * Math.cos(toRad(pt2.lat)) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        function isPointInPolygon(p, vs) {
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].lon, yi = vs[i].lat;
                const xj = vs[j].lon, yj = vs[j].lat;
                const intersect = ((yi > p.lat) !== (yj > p.lat)) &&
                    (p.lon < (xj - xi) * (p.lat - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- DISTANCE UTILS ---
        function distToSegment(p, v, w) {
            const l2 = ((v.lon - w.lon)**2 + (v.lat - w.lat)**2);
            if (l2 == 0) return haversine(p, v);
            let t = ((p.lon - v.lon) * (w.lon - v.lon) + (p.lat - v.lat) * (w.lat - v.lat)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { lon: v.lon + t * (w.lon - v.lon), lat: v.lat + t * (w.lat - v.lat) };
            return haversine(p, projection);
        }
        function getMinDistToCables(point, cables) {
            let minD = Infinity;
            cables.forEach(cable => {
                for (let i = 0; i < cable.length - 1; i++) {
                    const d = distToSegment(point, cable[i], cable[i+1]);
                    if (d < minD) minD = d;
                }
            });
            return minD;
        }

        // --- LOGIC FUNCTIONS ---
        function organizeHpByBoundary(xmlDoc) {
            const folders = Array.from(xmlDoc.querySelectorAll('Folder'));
            const hpFolder = folders.find(f => f.querySelector('name')?.textContent.trim().toUpperCase() === 'HP COVER');
            const boundaryFolder = folders.find(f => f.querySelector('name')?.textContent.trim().toUpperCase() === 'BOUNDARY FAT');
            if (!hpFolder || !boundaryFolder) return;

            const boundaries = [];
            const boundaryPlacemarks = boundaryFolder.querySelectorAll('Placemark');
            boundaryPlacemarks.forEach(pm => {
                const name = pm.querySelector('name')?.textContent.trim() || 'Unknown';
                let coordsText = '';
                const polygon = pm.querySelector('Polygon outerBoundaryIs LinearRing coordinates');
                const lineString = pm.querySelector('LineString coordinates');
                if (polygon) coordsText = polygon.textContent;
                else if (lineString) coordsText = lineString.textContent;

                if (coordsText) {
                    const coords = coordsText.trim().split(/\s+/).map(pair => {
                        const [lon, lat] = pair.split(',').map(Number);
                        return { lon, lat };
                    });
                    boundaries.push({ name: name, polygon: coords, hpCount: 0, element: pm });
                }
            });

            const hpPlacemarks = Array.from(hpFolder.getElementsByTagName('Placemark'));
            const categorizedHPs = {}; 
            const uncategorizedHPs = [];
            boundaries.forEach(b => categorizedHPs[b.name] = []);

            hpPlacemarks.forEach(pm => {
                const pt = pm.querySelector('Point coordinates');
                if (pt) {
                    const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                    const point = { lon, lat };
                    let matched = false;
                    for (const b of boundaries) {
                        if (isPointInPolygon(point, b.polygon)) {
                            categorizedHPs[b.name].push(pm);
                            b.hpCount++;
                            matched = true;
                            break; 
                        }
                    }
                    if (!matched) uncategorizedHPs.push(pm);
                } else {
                    uncategorizedHPs.push(pm); 
                }
            });

            while (hpFolder.firstChild) hpFolder.removeChild(hpFolder.firstChild);
            
            const fname = xmlDoc.createElement('name');
            fname.textContent = 'HP COVER';
            hpFolder.appendChild(fname);

            boundaries.forEach(b => {
                if (categorizedHPs[b.name].length > 0) {
                    const subFolder = xmlDoc.createElement('Folder');
                    const subName = xmlDoc.createElement('name');
                    subName.textContent = b.name;
                    subFolder.appendChild(subName);
                    categorizedHPs[b.name].forEach(pm => subFolder.appendChild(pm));
                    hpFolder.appendChild(subFolder);
                }
            });

            if (uncategorizedHPs.length > 0) {
                uncategorizedHPs.forEach(pm => hpFolder.appendChild(pm));
            }

            boundaries.forEach(b => {
                let descTag = Array.from(b.element.children).find(c => c.tagName === 'description');
                if (!descTag) {
                    descTag = xmlDoc.createElement('description');
                    b.element.appendChild(descTag);
                }
                descTag.textContent = `${b.hpCount} HP`;
            });
        }

        function autoRepositionPoints(xmlDoc) {
            const points = [];
            const cables = [];
            const placemarks = xmlDoc.querySelectorAll('Placemark');

            placemarks.forEach(pm => {
                const name = (pm.querySelector('name')?.textContent || '').toUpperCase();
                const parentFolder = pm.parentElement.querySelector('name')?.textContent?.toUpperCase() || '';
                
                const ls = pm.querySelector('LineString coordinates');
                if (ls && parentFolder === 'DISTRIBUTION CABLE') {
                    const coords = ls.textContent.trim().split(/\s+/).map(pair => {
                        const [lon, lat] = pair.split(',').map(Number);
                        return { lon, lat };
                    });
                    cables.push(coords);
                }

                const pt = pm.querySelector('Point coordinates');
                if (pt) {
                    const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                    let type = null;
                    if (parentFolder === 'FAT') type = 'FAT';
                    else if (parentFolder === 'SLACK HANGER') type = 'SLACK';
                    else if (parentFolder.includes('POLE') || name.includes('POLE') || name.includes('TIANG')) type = 'POLE';

                    if (type) {
                        points.push({ element: pt, lon, lat, type, parent: parentFolder, id: Math.random() });
                    }
                }
            });

            if (cables.length === 0 || points.length === 0) return;

            const processed = new Set();
            points.forEach(p1 => {
                if (processed.has(p1.id)) return;

                const cluster = [p1];
                processed.add(p1.id);

                points.forEach(p2 => {
                    if (!processed.has(p2.id)) {
                        const dist = haversine(p1, p2);
                        if (dist <= SNAP_TOLERANCE_METERS) {
                            cluster.push(p2);
                            processed.add(p2.id);
                        }
                    }
                });

                let anchor = null;
                const poles = cluster.filter(p => p.type === 'POLE');

                if (poles.length > 0) {
                    poles.sort((a, b) => getMinDistToCables(a, cables) - getMinDistToCables(b, cables));
                    anchor = poles[0];
                } else {
                    cluster.sort((a, b) => getMinDistToCables(a, cables) - getMinDistToCables(b, cables));
                    anchor = cluster[0];
                }

                cluster.forEach(p => {
                    if (p !== anchor) {
                        p.element.textContent = `${anchor.lon},${anchor.lat},0`;
                    }
                });
            });
        }

        function calculateLineLength(coordString) {
            const parts = coordString.trim().split(/\s+/);
            if (parts.length < 2) return 0;
            const points = parts.map(p => { const [lon, lat] = p.split(',').map(Number); return { lon, lat }; });
            let totalDist = 0;
            for (let i = 0; i < points.length - 1; i++) { totalDist += haversine(points[i], points[i+1]); }
            return Math.ceil(totalDist);
        }

        function injectDescriptionsAndCalc(xmlDoc) {
            if (CURRENT_MODE !== 'cluster') return; 
            const folders = xmlDoc.querySelectorAll('Folder');
            folders.forEach(folder => {
                let folderName = '';
                const nameNode = Array.from(folder.children).find(c => c.tagName === 'name');
                if (nameNode) folderName = nameNode.textContent.trim().toUpperCase();

                if (folderName === 'SLING WIRE') {
                    let totalMeters = 0;
                    const placemarks = folder.querySelectorAll('Placemark');
                    placemarks.forEach(pm => {
                        const ls = pm.querySelector('LineString coordinates');
                        if (ls) {
                            const len = calculateLineLength(ls.textContent);
                            totalMeters += len;
                            let nameTag = Array.from(pm.children).find(c => c.tagName === 'name');
                            if (!nameTag) { nameTag = xmlDoc.createElement('name'); pm.appendChild(nameTag); }
                            nameTag.textContent = `LineString — ${len} meters`;
                        }
                    });
                    if (totalMeters > 0) {
                        let descTag = Array.from(folder.children).find(c => c.tagName === 'description');
                        if (!descTag) { descTag = xmlDoc.createElement('description'); folder.appendChild(descTag); }
                        descTag.textContent = `${totalMeters} m`;
                    }
                }
                else if (folderName === 'DISTRIBUTION CABLE') {
                    let fatCount = 0;
                    const parentFolder = folder.parentElement;
                    if (parentFolder) {
                        const siblings = Array.from(parentFolder.children);
                        const fatFolder = siblings.find(el => el.tagName === 'Folder' && el.querySelector('name')?.textContent.trim() === 'FAT');
                        if (fatFolder) fatCount = fatFolder.getElementsByTagName('Placemark').length;
                    }
                    const b = 1; const c = fatCount; const a = b + c; const d = a * 20;
                    const placemarks = folder.querySelectorAll('Placemark');
                    placemarks.forEach(pm => {
                        const ls = pm.querySelector('LineString coordinates');
                        if (ls) {
                            const x = calculateLineLength(ls.textContent);
                            const e = Math.ceil((x + d) * 1.05);
                            let nameTag = Array.from(pm.children).find(child => child.tagName === 'name');
                            if (nameTag) {
                                const oldName = nameTag.textContent.trim();
                                const regex = /(\d+)(\s*M)$/i;
                                if (regex.test(oldName)) { nameTag.textContent = oldName.replace(regex, e + "$2"); }
                            }
                            const descText = `Deskripsi :\n\nTotal Route \t : ${x} m\nTotal Slack\t : ${a} unit (${b} slack FDT & ${c} slack FAT) @20 m\nToleransi\t : 5%\n\n Total Length Cable  : ${x} + ${d} ( x 5%) = ${e} m`;
                            let descTag = Array.from(pm.children).find(child => child.tagName === 'description');
                            if (!descTag) { descTag = xmlDoc.createElement('description'); pm.appendChild(descTag); }
                            descTag.textContent = descText;
                        }
                    });
                }
                else {
                    let suffix = null;
                    if (folderName === 'FAT') suffix = ' FAT';
                    else if (folderName === 'HP COVER') suffix = ' HP';
                    else if (folderName === 'HP UNCOVER') suffix = ' HP';
                    else if (folderName.includes('EXISTING POLE')) suffix = ' EXT POLE';
                    else if (folderName.includes('NEW POLE')) suffix = ' POLE';

                    if (suffix) {
                        // V36: Count subfolder items too for HP COVER
                        const placemarks = folder.getElementsByTagName('Placemark');
                        const count = placemarks.length;
                        if (count > 0) {
                            let descTag = Array.from(folder.children).find(c => c.tagName === 'description');
                            if (!descTag) { descTag = xmlDoc.createElement('description'); folder.appendChild(descTag); }
                            descTag.textContent = `${count}${suffix}`;
                        }
                    }
                }
            });
        }

        // --- CORE RESTRUCTURE LOGIC ---
        function getLineContext(placemarkNode) {
            const regex = /(?:LINE|LN|KABEL)[\s\-_]+([A-Z0-9]+)/i;
            const ignoreKeywords = ['DISTRIBUTION', 'DISTRIBUSI', 'SLACK', 'SLING', 'HANGER', 'FAT', 'FDT', 'POLE', 'TIANG', 'COVER', 'ODP', 'SPLITTER'];
            let curr = placemarkNode.parentElement;
            while (curr) {
                let name = '';
                for(let i=0; i<curr.children.length; i++) { if(curr.children[i].tagName === 'name') { name = curr.children[i].textContent.trim(); break; } }
                if (name) {
                    const upperName = name.toUpperCase();
                    const match = name.match(regex);
                    const isBlacklisted = ignoreKeywords.some(bad => upperName.includes(bad));
                    if (!isBlacklisted && match) return `LINE ${match[1].toUpperCase()}`;
                }
                if (curr.tagName === 'Document') break;
                curr = curr.parentElement;
            }
            return null;
        }

        function findFallbackGroupName(placemarkNode, structureList) {
            const ignoreList = [...structureList, 'DISTRIBUTION', 'ODP', 'SPLITTER', 'CLUSTER ID'];
            let bestName = 'LINE A'; 
            let curr = placemarkNode.parentElement;
            while (curr) {
                 let name = '';
                for(let i=0; i<curr.children.length; i++) { if(curr.children[i].tagName === 'name') { name = curr.children[i].textContent.trim(); break; } }
                if (name && curr.tagName === 'Folder') {
                    const upper = name.toUpperCase();
                    const isStandard = ignoreList.some(s => upper.includes(s));
                    if (!isStandard) bestName = name; 
                }
                if (curr.tagName === 'Document' || (name && name.toUpperCase().includes('CLUSTER ID'))) break;
                curr = curr.parentElement;
            }
            return bestName;
        }

        function restructureKML(xmlDoc) {
            const kmlDoc = xmlDoc.querySelector('Document');
            const targetStructure = (CURRENT_MODE === 'subfeeder') ? STRUCTURE_SUBFEEDER : STRUCTURE_CLUSTER;

            let boundaryClusterNode = null;
            const allFolders = Array.from(xmlDoc.querySelectorAll('Folder'));
            const boundaryOriginal = allFolders.find(f => f.querySelector('name')?.textContent?.toUpperCase().includes('BOUNDARY CLUSTER'));
            if (boundaryOriginal) boundaryClusterNode = boundaryOriginal.cloneNode(true);

            const allPlacemarks = Array.from(xmlDoc.querySelectorAll('Placemark')).filter(pm => {
                if (boundaryOriginal && boundaryOriginal.contains(pm)) return false;
                return true;
            });

            const fdtBucket = []; const lineBuckets = {}; const othersBucket = [];
            const addToLineBucket = (lineName, folderName, item, subFolderName = null) => {
                if (!lineBuckets[lineName]) lineBuckets[lineName] = {};
                if (!lineBuckets[lineName][folderName]) lineBuckets[lineName][folderName] = {};
                const subKey = subFolderName || 'MAIN';
                if (!lineBuckets[lineName][folderName][subKey]) lineBuckets[lineName][folderName][subKey] = [];
                lineBuckets[lineName][folderName][subKey].push(item);
            };
            const strictCableRegex = /\b\d{2,3}C\/\d{1,2}T\b/i;

            allPlacemarks.forEach(pm => {
                const name = (pm.querySelector('name')?.textContent || '').toUpperCase();
                const desc = (pm.querySelector('description')?.textContent || '').toUpperCase();
                const fullText = name + ' ' + desc;
                const isLine = pm.querySelector('LineString') !== null;
                const parentFolder = pm.parentElement;
                const parentName = (parentFolder.querySelector('name')?.textContent || '').toUpperCase();
                const grandParentName = (parentFolder.parentElement?.querySelector('name')?.textContent || '').toUpperCase();
                
                let lineName = 'MAIN';
                if (CURRENT_MODE === 'cluster') {
                    lineName = getLineContext(pm);
                    if (!lineName) lineName = findFallbackGroupName(pm, targetStructure);
                }

                let targetType = 'UNKNOWN';
                let subFolderName = null;

                if (parentName.includes('HP COVER')) { targetType = 'HP COVER'; } 
                else if (grandParentName.includes('HP COVER')) { targetType = 'HP COVER'; subFolderName = parentName; } 
                else if (parentName.includes('HP UNCOVER')) targetType = 'HP UNCOVER';
                else if (grandParentName.includes('HP UNCOVER')) { targetType = 'HP UNCOVER'; subFolderName = parentName; }
                
                if (targetType === 'UNKNOWN') {
                    if (CURRENT_MODE === 'subfeeder') {
                        if (isLine && (strictCableRegex.test(fullText) || name.includes('CABLE'))) { targetType = 'CABLE'; }
                        else if (!isLine && (name.includes('JC') || fullText.includes('JOINT CLOSURE') || /\b(288C|144C|96C|72C|48C)\b/.test(fullText))) { targetType = 'JOINT CLOSURE'; }
                        else {
                            const poleMatch = targetStructure.find(type => type.includes('POLE') && (name.includes(type) || parentName.includes(type)));
                            if (poleMatch) targetType = poleMatch;
                        }
                    } else {
                        if (!isLine && (name.includes('FDT') || desc.includes('FDT') || (/\b(288C|144C|96C|72C|48C)\b/.test(fullText) && !strictCableRegex.test(fullText)))) { targetType = 'FDT_GLOBAL'; }
                        else if (isLine && (strictCableRegex.test(fullText) || name.includes('CABLE'))) targetType = 'DISTRIBUTION CABLE';
                        else {
                             const match = targetStructure.find(type => name.includes(type) || parentName.includes(type));
                             if (match) targetType = match;
                        }
                    }
                }

                if (targetType === 'UNKNOWN') {
                    if (name.includes('SLING')) targetType = (CURRENT_MODE === 'subfeeder') ? 'UNKNOWN' : 'SLING WIRE';
                    else if (name.includes('SLACK')) targetType = 'SLACK HANGER';
                    else {
                        const match = targetStructure.find(type => name.includes(type) || parentName.includes(type));
                        if(match) targetType = match;
                    }
                }

                pm.remove();
                if (targetType === 'FDT_GLOBAL' && CURRENT_MODE === 'cluster') fdtBucket.push(pm);
                else if (targetType !== 'UNKNOWN') addToLineBucket(lineName, targetType, pm, subFolderName);
                else othersBucket.push(pm);
            });

            while (kmlDoc.firstChild) kmlDoc.removeChild(kmlDoc.firstChild);
            const root = xmlDoc.createElement('Folder');
            root.appendChild(createName(xmlDoc, (CURRENT_MODE === 'subfeeder') ? 'SUBFEEDER ID' : 'CLUSTER ID'));

            if (boundaryClusterNode) root.appendChild(boundaryClusterNode);
            if (fdtBucket.length > 0) root.appendChild(createFolder(xmlDoc, 'FDT', fdtBucket));

            if (CURRENT_MODE === 'subfeeder') {
                const mainData = lineBuckets['MAIN'] || {};
                targetStructure.forEach(folderName => {
                    const subData = mainData[folderName];
                    if (subData) {
                        const folder = xmlDoc.createElement('Folder');
                        folder.appendChild(createName(xmlDoc, folderName));
                        if (subData['MAIN']) subData['MAIN'].forEach(i => folder.appendChild(i));
                        Object.keys(subData).forEach(k => { if (k !== 'MAIN') folder.appendChild(createFolder(xmlDoc, k, subData[k])); });
                        root.appendChild(folder);
                    } else { root.appendChild(createFolder(xmlDoc, folderName, [])); }
                });
            } else {
                Object.keys(lineBuckets).sort().forEach(ln => {
                    const lnFolder = xmlDoc.createElement('Folder');
                    lnFolder.appendChild(createName(xmlDoc, ln));
                    targetStructure.forEach(folderName => {
                        const subData = lineBuckets[ln][folderName];
                        if (subData) {
                            const folder = xmlDoc.createElement('Folder');
                            folder.appendChild(createName(xmlDoc, folderName));
                            if (subData['MAIN']) subData['MAIN'].forEach(i => folder.appendChild(i));
                            Object.keys(subData).forEach(k => { if (k !== 'MAIN') folder.appendChild(createFolder(xmlDoc, k, subData[k])); });
                            lnFolder.appendChild(folder);
                        } else { lnFolder.appendChild(createFolder(xmlDoc, folderName, [])); }
                    });
                    root.appendChild(lnFolder);
                });
            }
            if (othersBucket.length > 0) root.appendChild(createFolder(xmlDoc, 'OTHERS', othersBucket));
            kmlDoc.appendChild(root);
            return { mode: CURRENT_MODE, lines: Object.keys(lineBuckets) };
        }

        function createName(xml, text) { const n = xml.createElement('name'); n.textContent = text; return n; }
        function createFolder(xml, name, items) { 
            const f = xml.createElement('Folder'); 
            f.appendChild(createName(xml, name)); 
            items.forEach(i => f.appendChild(i)); 
            return f; 
        }

        function applyStyles(xmlDoc) {
            const placemarks = xmlDoc.querySelectorAll('Placemark');
            const doc = xmlDoc.querySelector('Document');
            const stylesCreated = new Set();
            const styleB = xmlDoc.createElement('Style'); styleB.id = 'style_boundary';
            styleB.innerHTML = `<LineStyle><color>4dffffff</color><width>2</width></LineStyle><PolyStyle><color>4dffffff</color></PolyStyle>`;
            doc.appendChild(styleB);

            placemarks.forEach(pm => {
                const name = (pm.querySelector('name')?.textContent || '').toUpperCase();
                const desc = (pm.querySelector('description')?.textContent || '').toUpperCase();
                const fullText = name + ' ' + desc;
                const folderName = pm.parentElement.querySelector('name')?.textContent || '';
                const grandParentName = pm.parentElement.parentElement?.querySelector('name')?.textContent || '';

                if (folderName.includes('BOUNDARY CLUSTER')) { setStyle(pm, 'style_boundary'); return; }
                let rule = null;

                if (CURRENT_MODE === 'cluster') {
                    rule = RULES_CLUSTER.find(r => {
                        if (r.folder !== '-' && r.folder === folderName) return true;
                        if (folderName === 'DISTRIBUTION CABLE' && r.line !== '-' && fullText.includes(r.line)) return true;
                        if (r.placemark !== '-' && fullText.includes(r.placemark)) return true;
                        return false;
                    });
                    if (!rule) {
                        if (grandParentName.includes('HP COVER')) rule = RULES_CLUSTER.find(r => r.folder === 'HP COVER');
                        else if (grandParentName.includes('HP UNCOVER')) rule = RULES_CLUSTER.find(r => r.folder === 'HP UNCOVER');
                    }
                } else {
                    if (folderName === 'CABLE') {
                        const coreColors = { '288C': '#FFAA00', '144C': '#FFFF00', '96C': '#FF0000', '48C': '#AA00FF' };
                        const match = Object.keys(coreColors).find(k => fullText.includes(k));
                        rule = { colorCode: match ? coreColors[match] : '#00AAFF', styleLink: '-', placemark: '-' };
                    }
                    else if (folderName === 'JOINT CLOSURE') {
                        const isJC = name.includes('JC');
                        const coreMatch = fullText.match(/\b(\d+)C\b/);
                        const core = coreMatch ? coreMatch[0] : '48C';
                        const coreMap = { '288C': '#FFAA00', '144C': '#FFFF00', '96C': '#FF0000', '72C': '#550000', '48C': '#AA00FF', '36C': '#FF00FF', '24C': '#00FF00' };
                        const color = coreMap[core] || '#AA00FF';
                        
                        if (isJC) rule = { colorCode: color, styleLink: 'http://maps.google.com/mapfiles/kml/shapes/forbidden.png', placemark: 'JC_' + core };
                        else rule = { colorCode: color, styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png', placemark: 'FDT_' + core };
                    }
                    else if (folderName.includes('POLE')) {
                        let pColor = '#550000';
                        const upperFolder = folderName.toUpperCase();
                        if (upperFolder.includes('NEW')) {
                            if (upperFolder.includes('9-')) pColor = '#FF0000';
                            else if (upperFolder.includes('7-5') || upperFolder.includes('7-4')) pColor = '#00FF00';
                            else if (upperFolder.includes('7-3')) pColor = '#00FFFF';
                            else if (upperFolder.includes('7-2.5')) pColor = '#AA00FF';
                        }
                        rule = { colorCode: pColor, styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png', placemark: '-' };
                    }
                    else {
                        rule = RULES_SUBFEEDER.find(r => r.folder === folderName);
                    }
                }

                if (rule) {
                    const safeName = rule.placemark !== '-' ? rule.placemark : folderName;
                    const styleId = `style_${rule.colorCode.replace('#','')}_${safeName.replace(/[^a-z0-9]/gi,'')}_${Math.floor(Math.random()*1000)}`;
                    if (!stylesCreated.has(styleId)) {
                        const style = xmlDoc.createElement('Style'); style.id = styleId;
                        const kmlColor = 'ff' + rule.colorCode.replace('#', '').match(/.{2}/g).reverse().join('');
                        let styleContent = `<LabelStyle><color>${kmlColor}</color><scale>${TEXT_SIZE}</scale></LabelStyle>`;
                        if (rule.styleLink !== '-') styleContent += `<IconStyle><color>${kmlColor}</color><scale>1.1</scale><Icon><href>${rule.styleLink}</href></Icon></IconStyle>`;
                        styleContent += `<LineStyle><color>${kmlColor}</color><width>2</width></LineStyle><PolyStyle><color>66${kmlColor.substring(2)}</color></PolyStyle>`;
                        style.innerHTML = styleContent;
                        doc.appendChild(style);
                        stylesCreated.add(styleId);
                    }
                    setStyle(pm, styleId);
                }
            });
        }

        function setStyle(pm, id) {
            let url = pm.querySelector('styleUrl');
            if (!url) { url = pm.ownerDocument.createElement('styleUrl'); pm.appendChild(url); }
            url.textContent = '#' + id;
        }

        function displayTree(result) {
            const list = document.getElementById('folderList');
            const mode = result.mode;
            let html = `<div class="tree-item"><span class="tree-folder" style="color:#aaa">BOUNDARY CLUSTER</span></div>`;
            if (result.lines.includes('FDT') || mode === 'cluster') html += `<div class="tree-item"><span class="tree-folder">FDT</span></div>`;
            if (mode === 'subfeeder') {
                html += `<div class="tree-item"><span class="tree-folder">SUBFEEDER ID</span></div>`;
                STRUCTURE_SUBFEEDER.forEach(f => { html += `<div class="tree-item" style="margin-left:20px; font-size:0.9em; color:#888">${f}</div>`; });
            } else {
                result.lines.forEach(l => { html += `<div class="tree-item"><span class="tree-folder">${l}</span></div>`; });
            }
            list.innerHTML = html;
            document.getElementById('preview').classList.remove('hidden');
        }
    </script>
</body>
</html>


