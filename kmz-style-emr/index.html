<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMZ Styler - V13 (Fix Line Grouping)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
      window.addEventListener('load', function() {
        var script = document.createElement('script');
        script.async = true;
        script.src = 'https://www.googletagmanager.com/gtag/js?id=G-T12DERDD3M';
        document.head.appendChild(script);
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-T12DERDD3M');
      });
    </script>
    
    <style>
        /* --- MAIN STYLES --- */
        :root { --bg-body: #0d0d0d; --bg-surface: #171717; --bg-surface-hover: #222; --border: #333; --primary: #3b82f6; --primary-hover: #2563eb; --text-main: #ededed; --text-muted: #888; --success: #22c55e; --error: #ef4444; --radius: 8px; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: var(--bg-body); color: var(--text-main); line-height: 1.5; min-height: 100vh; display: flex; justify-content: center; padding-top: 5vh; }
        .container { width: 100%; max-width: 680px; padding: 0 1.5rem; }
        header { margin-bottom: 2rem; text-align: center; }
        h1 { font-size: 1.75rem; font-weight: 600; letter-spacing: -0.03em; margin-bottom: 0.5rem; background: linear-gradient(to bottom right, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: var(--text-muted); font-size: 0.95rem; }
        .card { background: var(--bg-surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 2rem; margin-bottom: 1.5rem; box-shadow: 0 10px 30px -10px rgba(0,0,0,0.5); }
        .mode-selector { display: flex; background: #222; padding: 4px; border-radius: 8px; margin-bottom: 1.5rem; }
        .mode-option { flex: 1; text-align: center; padding: 10px; cursor: pointer; font-size: 0.9rem; font-weight: 600; color: var(--text-muted); border-radius: 6px; transition: all 0.2s; }
        .mode-option.active { color: #fff; background: var(--primary); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .file-drop-area { border: 2px dashed var(--border); border-radius: var(--radius); height: 140px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; background: rgba(255,255,255,0.01); margin-bottom: 1.5rem; color: var(--text-muted); }
        .file-drop-area:hover { border-color: var(--primary); background: rgba(59, 130, 246, 0.05); color: var(--text-main); }
        .file-drop-area.active { border-color: var(--success); background: rgba(34, 197, 94, 0.05); }
        #fileLabel { font-size: 0.95rem; pointer-events: none; transition: color 0.2s; }
        input[type="file"] { display: none; }
        .btn-group { display: flex; gap: 10px; justify-content: center; flex-direction: column; }
        .row-btn { display: flex; gap: 10px; justify-content: center; }
        button { padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 0.9rem; font-weight: 500; cursor: pointer; transition: all 0.2s; border: none; }
        button.primary { background: var(--primary); color: white; box-shadow: 0 2px 10px rgba(59, 130, 246, 0.2); }
        button.primary:hover:not(:disabled) { background: var(--primary-hover); transform: translateY(-1px); }
        button.primary:disabled { background: var(--bg-surface-hover); color: var(--text-muted); cursor: not-allowed; box-shadow: none; }
        button.secondary { background: transparent; border: 1px solid var(--border); color: var(--text-main); }
        button.secondary:hover { border-color: var(--text-muted); background: var(--bg-surface-hover); }
        button.success { background: var(--success); color: white; margin-top: 10px; }
        button.success:hover { filter: brightness(1.1); }
        #status { margin-top: 1.5rem; font-size: 0.9rem; text-align: center; min-height: 24px; }
        .folder-list { background: #111; border: 1px solid var(--border); border-radius: var(--radius); padding: 1rem; max-height: 400px; overflow-y: auto; font-family: 'Menlo', 'Monaco', 'Courier New', monospace; font-size: 0.85rem; }
        .tree-item { margin-left: 1.5rem; border-left: 1px solid #333; padding-left: 0.75rem; margin-bottom: 0.25rem; position: relative; }
        .tree-folder { color: #fbbf24; font-weight: 600; }
        .tree-subfolder { color: #4ade80; }
        .tree-info { color: #666; font-size: 0.8em; margin-left: 0.5rem; }
        .hidden { display: none; }
        .loading-spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: #fff; animation: spin 0.8s linear infinite; margin-right: 8px; vertical-align: text-bottom; }
        @keyframes spin { to { transform: rotate(360deg); } }
        ::-webkit-scrollbar { width: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

        /* --- README MODAL STYLES --- */
        .top-right-btn { position: absolute; top: 1.5rem; right: 1.5rem; z-index: 100; }
        .btn-readme { background: transparent; border: 1px solid var(--border); color: var(--text-muted); padding: 8px 16px; border-radius: 20px; font-size: 0.85rem; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .btn-readme:hover { border-color: var(--primary); color: var(--text-main); background: rgba(59, 130, 246, 0.1); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(4px); z-index: 1000; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: all 0.3s ease; }
        .modal-overlay.open { opacity: 1; visibility: visible; }
        .modal-box { background: var(--bg-surface); border: 1px solid var(--border); border-radius: var(--radius); width: 90%; max-width: 800px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 20px 50px rgba(0,0,0,0.5); transform: translateY(20px); transition: transform 0.3s ease; }
        .modal-overlay.open .modal-box { transform: translateY(0); }
        .modal-header { padding: 1.5rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: #111; border-radius: var(--radius) var(--radius) 0 0; }
        .modal-header h2 { font-size: 1.2rem; margin: 0; color: var(--text-main); }
        .close-modal { background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; padding: 0; line-height: 1; }
        .close-modal:hover { color: var(--error); }
        .modal-body { padding: 2rem; overflow-y: auto; font-size: 0.95rem; line-height: 1.6; color: #ccc; }
        .modal-body::-webkit-scrollbar { width: 8px; }
        .modal-body::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        .modal-body::-webkit-scrollbar-track { background: #111; }
        .md-content h1, .md-content h2 { color: var(--text-main); margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 1px solid #333; padding-bottom: 0.5rem; }
        .md-content h3 { color: var(--primary); margin-top: 1.5rem; margin-bottom: 0.75rem; }
        .md-content ul, .md-content ol { padding-left: 1.5rem; margin-bottom: 1rem; }
        .md-content li { margin-bottom: 0.5rem; }
        .md-content code { background: #222; padding: 2px 6px; border-radius: 4px; color: #fbbf24; font-family: monospace; border: 1px solid #333; }
        .md-content pre { background: #111; padding: 1rem; border-radius: 6px; border: 1px solid #333; overflow-x: auto; margin-bottom: 1rem; }
        .md-content pre code { background: transparent; padding: 0; border: none; color: #ccc; }
        .md-content blockquote { border-left: 3px solid var(--primary); background: rgba(59, 130, 246, 0.1); padding: 1rem; margin: 1rem 0; border-radius: 0 6px 6px 0; }
        .md-content table { width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.9rem; }
        .md-content th, .md-content td { border: 1px solid #444; padding: 10px; text-align: left; }
        .md-content th { background: #222; color: #fff; font-weight: 600; }
        .md-content tr:nth-child(even) { background: #1a1a1a; }
        .md-content a { color: var(--primary); text-decoration: none; }
        .md-content a:hover { text-decoration: underline; }
    </style>
</head>
<body>

    <div class="top-right-btn">
        <button class="btn-readme" onclick="openReadme()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            Readme / Help
        </button>
    </div>

    <div id="readmeModal" class="modal-overlay" onclick="if(event.target === this) toggleModal(false)">
        <div class="modal-box">
            <div class="modal-header">
                <h2>Dokumentasi & Rules</h2>
                <button class="close-modal" onclick="toggleModal(false)">×</button>
            </div>
            <div class="modal-body md-content" id="mdContainer">
                <div style="text-align:center; padding: 2rem; color: #888;">
                    <span class="loading-spinner"></span> Loading documentation...
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <header>
            <h1>KMZ Style EMR by xsanosaurus</h1>
            <p class="subtitle">AutoCAD Logic V13 (Preserve Line Structure)</p>
        </header>

        <div class="card">
            <div class="mode-selector">
                <div class="mode-option active" onclick="setMode('cluster')" id="btn-cluster">CLUSTER MODE</div>
                <div class="mode-option" onclick="setMode('subfeeder')" id="btn-subfeeder">SUBFEEDER MODE</div>
            </div>

            <label class="file-drop-area" id="dropArea">
                <span id="fileLabel">Drag & drop KMZ/KML here or click to upload</span>
                <input type="file" id="kmzFile" accept=".kmz, .kml" />
            </label>

            <div class="btn-group">
                <div class="row-btn">
                    <button id="processBtn" class="primary" disabled>Process File</button>
                    <button id="resetBtn" class="secondary">Reset</button>
                </div>
            </div>
            
            <div id="status"></div>
        </div>

        <div id="preview" class="hidden">
            <div class="card" style="padding: 1rem;">
                <h3 style="font-size: 0.9rem; margin-bottom: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Structure Preview</h3>
                <div class="folder-list" id="folderList"></div>
            </div>
        </div>
    </div>

    <script>
        // --- README LOADER LOGIC ---
        let readmeLoaded = false;
        async function openReadme() {
            toggleModal(true);
            if (readmeLoaded) return;
            const container = document.getElementById('mdContainer');
            try {
                const response = await fetch('README.md');
                if (!response.ok) throw new Error(`HTTP Error: ${response.status}`);
                const markdownText = await response.text();
                container.innerHTML = marked.parse(markdownText);
                readmeLoaded = true;
            } catch (error) {
                console.error("Gagal load README:", error);
                container.innerHTML = `
                    <div style="text-align:center; color: var(--error); padding: 20px;">
                        <p><strong>Gagal memuat dokumentasi.</strong></p>
                        <p style="font-size:0.9em; color:#888;">Pastikan file <code>README.md</code> ada.</p>
                        <p style="font-size:0.8em; margin-top:10px;">Error: ${error.message}</p>
                    </div>
                `;
            }
        }
        function toggleModal(show) {
            const modal = document.getElementById('readmeModal');
            if (show) { modal.classList.add('open'); document.body.style.overflow = 'hidden'; } 
            else { modal.classList.remove('open'); document.body.style.overflow = ''; }
        }
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') toggleModal(false); });

        // --- CONFIGURATION ---
        let CURRENT_MODE = 'cluster'; 
        const TEXT_SIZE = 1.0; 
        const SNAP_TOLERANCE_METERS = 15; 

        // --- CLUSTER STRUCTURE ---
        const STRUCTURE_CLUSTER = [
            'BOUNDARY FAT', 'FAT', 'HP COVER', 'HP UNCOVER',
            'EXISTING POLE EMR 7-2.5', 'EXISTING POLE EMR 7-3', 'EXISTING POLE EMR 7-4', 'EXISTING POLE EMR 9-4',
            'EXISTING POLE PARTNER 7-4', 'EXISTING POLE PARTNER 9-4',
            'NEW POLE 7-2.5', 'NEW POLE 7-3', 'NEW POLE 7-4', 'NEW POLE 9-4',
            'DISTRIBUTION CABLE', 'SLACK HANGER', 'SLING WIRE'
        ];

        const RULES_CLUSTER = [
            { folder: '-', placemark: '288C', line: '-', polygon: '-', colorCode: '#AA0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '144C', line: '-', polygon: '-', colorCode: '#AAFF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '96C', line: '-', polygon: '-', colorCode: '#00FFFF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '72C', line: '-', polygon: '-', colorCode: '#0000FF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: '-', placemark: '48C', line: '-', polygon: '-', colorCode: '#AA00FF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: 'BOUNDARY FAT', placemark: '-', line: '-', polygon: '-', colorCode: '#009999', styleLink: '-' },
            { folder: 'FAT', placemark: '-', line: '-', polygon: '-', colorCode: '#FFFF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/triangle.png' },
            { folder: 'HP COVER', placemark: '-', line: '-', polygon: '-', colorCode: '#00FF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/homegardenbusiness.png' },
            { folder: 'HP UNCOVER', placemark: '-', line: '-', polygon: '-', colorCode: '#ff0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/homegardenbusiness.png' },
            { folder: 'NEW POLE 9-4', placemark: 'NEW POLE 9-4', line: '-', polygon: '-', colorCode: '#FF0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'NEW POLE 7-4', placemark: 'NEW POLE 7-4', line: '-', polygon: '-', colorCode: '#00FF00', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'NEW POLE 7-3', placemark: 'NEW POLE 7-3', line: '-', polygon: '-', colorCode: '#00FFFF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'NEW POLE 7-2.5', placemark: 'NEW POLE 7-2.5', line: '-', polygon: '-', colorCode: '#AA00FF', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 7-2.5', placemark: 'EXISTING POLE EMR 7-2.5', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 7-3', placemark: 'EXISTING POLE EMR 7-3', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 7-4', placemark: 'EXISTING POLE EMR 7-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE EMR 9-4', placemark: 'EXISTING POLE EMR 9-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE PARTNER 7-4', placemark: 'EXISTING POLE PARTNER 7-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'EXISTING POLE PARTNER 9-4', placemark: 'EXISTING POLE PARTNER 9-4', line: '-', polygon: '-', colorCode: '#550000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '24C', polygon: '-', colorCode: '#00FF00', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '36C', polygon: '-', colorCode: '#FF00FF', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '48C', polygon: '-', colorCode: '#AA00FF', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '72C', polygon: '-', colorCode: '#550000', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '96C', polygon: '-', colorCode: '#FF0000', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '144C', polygon: '-', colorCode: '#FFFF00', styleLink: '-' },
            { folder: 'DISTRIBUTION CABLE', placemark: '-', line: '288C', polygon: '-', colorCode: '#FFAA00', styleLink: '-' },
            { folder: 'SLING WIRE', placemark: '-', line: '-', polygon: '-', colorCode: '#00FFFF', styleLink: '-' },
            { folder: 'FDT', placemark: 'FDT', line: '-', polygon: '-', colorCode: '#AA0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png' },
            { folder: 'SLACK HANGER', placemark: 'SLACK', line: '-', polygon: '-', colorCode: '#ff0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/target.png' }
        ];

        // --- UPDATED SUBFEEDER STRUCTURE ---
        const STRUCTURE_SUBFEEDER = [
            'FDT', 'JOINT CLOSURE', 'EXISTING POLE EMR 7-2.5', 'EXISTING POLE EMR 7-3', 'EXISTING POLE EMR 7-4', 
            'EXISTING POLE EMR 7-5', 'EXISTING POLE EMR 9-5', 'EXISTING POLE EMR 9-4', 
            'EXISTING POLE PARTNER 7-4', 'EXISTING POLE PARTNER 9-4', 'NEW POLE 7-5', 'NEW POLE 9-5', 
            'NEW POLE 7-4', 'NEW POLE 9-4', 'CABLE', 'SLACK HANGER'
        ];
        
        const RULES_SUBFEEDER = [
            { folder: 'SLACK HANGER', placemark: 'SLACK', line: '-', polygon: '-', colorCode: '#ff0000', styleLink: 'http://maps.google.com/mapfiles/kml/shapes/target.png' }
        ];

        let kmzFile = null;
        let processedKMZ = null;
        let processedHPDB = null;

        const kmzInput = document.getElementById('kmzFile');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        const fileLabel = document.getElementById('fileLabel');
        const dropArea = document.getElementById('dropArea');

        function setMode(mode) {
            CURRENT_MODE = mode;
            document.querySelectorAll('.mode-option').forEach(el => el.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
        }

        dropArea.addEventListener('dragover', (e) => { e.preventDefault(); dropArea.classList.add('active'); });
        dropArea.addEventListener('dragleave', () => dropArea.classList.remove('active'));
        dropArea.addEventListener('drop', (e) => { e.preventDefault(); dropArea.classList.remove('active'); if(e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]); });
        kmzInput.addEventListener('change', (e) => { if (e.target.files.length) handleFile(e.target.files[0]); });

        function handleFile(file) {
            if(!file.name.toLowerCase().endsWith('.kmz') && !file.name.toLowerCase().endsWith('.kml')) { alert('File harus .KMZ atau .KML'); return; }
            kmzFile = file;
            fileLabel.textContent = `${file.name} (${(file.size/1024).toFixed(1)} KB)`;
            fileLabel.style.color = 'var(--primary)';
            processBtn.disabled = false;
        }

        processBtn.addEventListener('click', async () => {
            if (!kmzFile) return;
            processBtn.disabled = true;
            statusDiv.innerHTML = '<span class="loading-spinner"></span>Processing...';

            try {
                let xmlDoc;
                if (kmzFile.name.toLowerCase().endsWith('.kmz')) {
                    const zip = new JSZip();
                    const contents = await zip.loadAsync(kmzFile);
                    const kmlName = Object.keys(contents.files).find(n => n.endsWith('.kml'));
                    const kmlString = await contents.files[kmlName].async('string');
                    xmlDoc = new DOMParser().parseFromString(kmlString, 'text/xml');
                } else {
                    const kmlString = await kmzFile.text();
                    xmlDoc = new DOMParser().parseFromString(kmlString, 'text/xml');
                }

                const tree = restructureKML(xmlDoc);
                
                if (CURRENT_MODE === 'cluster') {
                    organizeHpByBoundary(xmlDoc);
                    autoRepositionPoints(xmlDoc);
                }

                applyStyles(xmlDoc);
                injectDescriptionsAndCalc(xmlDoc);
                displayTree(tree);

                if (CURRENT_MODE === 'cluster') {
                    processedHPDB = generateHPDB(xmlDoc, tree.rootName);
                }

                const serializer = new XMLSerializer();
                const newKml = serializer.serializeToString(xmlDoc);
                const zipOut = new JSZip();
                zipOut.file("doc.kml", newKml);
                processedKMZ = await zipOut.generateAsync({ type: 'blob' });

                statusDiv.innerHTML = '<span style="color:var(--success)">✅ Done!</span>';
                
                const dlBtn = document.createElement('button');
                dlBtn.className = 'success';
                dlBtn.textContent = `Download KMZ Result`;
                dlBtn.onclick = () => {
                    const url = URL.createObjectURL(processedKMZ);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `STYLED_${CURRENT_MODE.toUpperCase()}_${kmzFile.name.replace(/\.kml$/i, '.kmz')}`;
                    a.click();
                };

                const btnGroup = document.querySelector('.btn-group');
                const oldBtns = btnGroup.querySelectorAll('.success');
                oldBtns.forEach(b => b.remove());
                btnGroup.appendChild(dlBtn);

                if (processedHPDB) {
                    const csvBtn = document.createElement('button');
                    csvBtn.className = 'success';
                    csvBtn.style.background = '#8b5cf6';
                    csvBtn.textContent = `Download HPDB Result (CSV)`;
                    csvBtn.onclick = () => {
                        const blob = new Blob([processedHPDB], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `HPDB_${kmzFile.name.replace(/\.k?mz|\.kml/i, '')}.csv`;
                        a.click();
                    };
                    btnGroup.appendChild(csvBtn);
                }

            } catch (err) {
                statusDiv.innerHTML = `<span style="color:var(--error)">Error: ${err.message}</span>`;
                console.error(err);
            } finally {
                processBtn.disabled = false;
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => location.reload());

        // --- HPDB GENERATOR V11 (SCOPE FIX) ---
        function generateHPDB(xmlDoc, rootNameRaw) {
            const headers = [
                'Pole ID', 'Pole Latitude', 'Pole Longitude', 'FAT Address', 'Province', 
                'regency_city', 'district', 'subdistrict', 'postalcode', 'Roll_Out_ID', 
                'acquisition_class', 'acquisition_tier', 'competition', 'project_id', 'Area', 
                'Complex_name', 'Clustername', 'Commercial_name', 'Rw', 'Rt', 'address_prefix', 
                'street', 'address_suffix', 'sub_address_prefix', 'sub_address', 'sub_address_suffix', 
                'block', 'homenumber', 'dwelling_type', 'building_type', 'building_property_name', 
                'building_property_location', 'floor', 'unit', 'homepass_source', 'oltcode', 
                'fdtcode', 'fatcode', 'RFSDate', 'Latitude_homepass', 'Longitude_homepass', 'residential_service_ready'
            ];
            
            let csvContent = headers.join(',') + '\n';
            
            // 1. Get Root Folder (Detected ID)
            const rootFolder = Array.from(xmlDoc.querySelectorAll('Folder')).find(f => {
                const n = f.querySelector('name');
                return n && n.textContent === rootNameRaw;
            });

            if (!rootFolder) return csvContent; 

            // 2. Iterate each LINE folder (Immediate Children of Root)
            const lineFolders = Array.from(rootFolder.children).filter(child => child.tagName === 'Folder' && child.querySelector('name')?.textContent !== 'OTHERS' && child.querySelector('name')?.textContent !== 'FDT');

            lineFolders.forEach(lineFolder => {
                const lineName = lineFolder.querySelector('name').textContent.trim(); 

                // 3. Localize Data Collecting within THIS Line Folder
                // FATs
                const fatFolder = Array.from(lineFolder.children).find(c => c.tagName === 'Folder' && c.querySelector('name')?.textContent === 'FAT');
                const localFatPoints = [];
                if (fatFolder) {
                    fatFolder.querySelectorAll('Placemark').forEach(pm => {
                        const pt = pm.querySelector('Point coordinates');
                        if(pt) {
                            const name = pm.querySelector('name')?.textContent.trim() || 'FAT';
                            const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                            localFatPoints.push({ name, lon, lat });
                        }
                    });
                }

                // POLES (Search in all pole folders within this line)
                const localPolePoints = [];
                const subFolders = Array.from(lineFolder.querySelectorAll('Folder'));
                subFolders.forEach(f => {
                    const n = f.querySelector('name')?.textContent.trim().toUpperCase() || '';
                    if (n.includes('POLE') || n.includes('TIANG')) {
                        f.querySelectorAll('Placemark').forEach(pm => {
                            const pt = pm.querySelector('Point coordinates');
                            if(pt) {
                                const name = pm.querySelector('name')?.textContent.trim() || 'Unknown';
                                const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                                localPolePoints.push({ name, lon, lat });
                            }
                        });
                    }
                });

                // HP COVER
                const hpCoverFolder = Array.from(lineFolder.children).find(c => c.tagName === 'Folder' && c.querySelector('name')?.textContent === 'HP COVER');
                if (hpCoverFolder) {
                    const fatSubFolders = Array.from(hpCoverFolder.querySelectorAll('Folder')); // Subfolders like "FAT A01"
                    
                    fatSubFolders.forEach(sub => {
                        const subName = sub.querySelector('name').textContent.trim(); 
                        const fatCode = subName.slice(-3); // "A01"
                        
                        // Find Anchor FAT (Strict Local Scope)
                        let anchorFat = localFatPoints.find(f => f.name.toUpperCase().includes(fatCode.toUpperCase()));
                        
                        let anchorPole = { name: '', lon: '', lat: '' };
                        if (anchorFat && localPolePoints.length > 0) {
                            const exactMatch = localPolePoints.find(p => haversine(p, anchorFat) < 0.5);
                            if (exactMatch) { anchorPole = exactMatch; } 
                            else { anchorPole = localPolePoints.sort((a, b) => haversine(a, anchorFat) - haversine(b, anchorFat))[0]; }
                        }

                        sub.querySelectorAll('Placemark').forEach(hp => {
                            const pt = hp.querySelector('Point coordinates');
                            if (pt) {
                                const hpName = hp.querySelector('name')?.textContent.trim() || '';
                                const [hpLon, hpLat] = pt.textContent.trim().split(',').map(Number);
                                const row = [
                                    `"${anchorPole.name}"`, anchorPole.lat, anchorPole.lon, '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 
                                    'JLN.', '', '', '', '', '', '', `"${hpName}"`, '', '', '', '', '', '', '', '', '', 
                                    `"${lineName}"`, `"${fatCode}"`, '', hpLat, hpLon, ''
                                ];
                                csvContent += row.join(',') + '\n';
                            }
                        });
                    });
                }
            });

            return csvContent;
        }

        // --- SPATIAL UTILS ---
        function toRad(val) { return val * Math.PI / 180; }
        function haversine(pt1, pt2) {
            const R = 6371000; 
            const dLat = toRad(pt2.lat - pt1.lat);
            const dLon = toRad(pt2.lon - pt1.lon);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(pt1.lat)) * Math.cos(toRad(pt2.lat)) * Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        function isPointInPolygon(p, vs) {
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].lon, yi = vs[i].lat;
                const xj = vs[j].lon, yj = vs[j].lat;
                const intersect = ((yi > p.lat) !== (yj > p.lat)) && (p.lon < (xj - xi) * (p.lat - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        function distToSegment(p, v, w) {
            const l2 = ((v.lon - w.lon)**2 + (v.lat - w.lat)**2);
            if (l2 == 0) return haversine(p, v);
            let t = ((p.lon - v.lon) * (w.lon - v.lon) + (p.lat - v.lat) * (w.lat - v.lat)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { lon: v.lon + t * (w.lon - v.lon), lat: v.lat + t * (w.lat - v.lat) };
            return haversine(p, projection);
        }
        function getMinDistToCables(point, cables) {
            let minD = Infinity;
            cables.forEach(cable => {
                for (let i = 0; i < cable.length - 1; i++) {
                    const d = distToSegment(point, cable[i], cable[i+1]);
                    if (d < minD) minD = d;
                }
            });
            return minD;
        }

        // --- LOGIC FUNCTIONS (V6 - Multi-Line Iteration) ---
        function organizeHpByBoundary(xmlDoc) {
            const allFolders = Array.from(xmlDoc.querySelectorAll('Folder'));
            const boundaryFolders = allFolders.filter(f => f.querySelector('name')?.textContent.trim().toUpperCase() === 'BOUNDARY FAT');

            boundaryFolders.forEach(boundaryFolder => {
                const parent = boundaryFolder.parentElement;
                if (!parent) return;

                const siblings = Array.from(parent.children).filter(c => c.tagName === 'Folder');
                const hpFolder = siblings.find(f => f.querySelector('name')?.textContent.trim().toUpperCase() === 'HP COVER');
                if (!hpFolder) return;

                const boundaries = [];
                boundaryFolder.querySelectorAll('Placemark').forEach(pm => {
                    const name = pm.querySelector('name')?.textContent.trim() || 'Unknown';
                    let coordsText = '';
                    const polygon = pm.querySelector('Polygon outerBoundaryIs LinearRing coordinates');
                    const lineString = pm.querySelector('LineString coordinates');
                    if (polygon) coordsText = polygon.textContent;
                    else if (lineString) coordsText = lineString.textContent;

                    if (coordsText) {
                        const coords = coordsText.trim().split(/\s+/).map(pair => {
                            const [lon, lat] = pair.split(',').map(Number);
                            return { lon, lat };
                        });
                        boundaries.push({ name: name, polygon: coords, hpCount: 0, element: pm });
                    }
                });

                const hpPlacemarks = Array.from(hpFolder.getElementsByTagName('Placemark'));
                const categorizedHPs = {}; 
                const uncategorizedHPs = [];
                boundaries.forEach(b => categorizedHPs[b.name] = []);

                hpPlacemarks.forEach(pm => {
                    const pt = pm.querySelector('Point coordinates');
                    if (pt) {
                        const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                        const point = { lon, lat };
                        let matched = false;
                        for (const b of boundaries) {
                            if (isPointInPolygon(point, b.polygon)) {
                                categorizedHPs[b.name].push(pm);
                                b.hpCount++;
                                matched = true;
                                break; 
                            }
                        }
                        if (!matched) uncategorizedHPs.push(pm);
                    } else { uncategorizedHPs.push(pm); }
                });

                while (hpFolder.firstChild) hpFolder.removeChild(hpFolder.firstChild);
                const fname = xmlDoc.createElement('name');
                fname.textContent = 'HP COVER';
                hpFolder.appendChild(fname);

                boundaries.forEach(b => {
                    if (categorizedHPs[b.name].length > 0) {
                        const subFolder = xmlDoc.createElement('Folder');
                        const subName = xmlDoc.createElement('name');
                        subName.textContent = b.name;
                        subFolder.appendChild(subName);
                        categorizedHPs[b.name].forEach(pm => subFolder.appendChild(pm));
                        hpFolder.appendChild(subFolder);
                    }
                });

                boundaries.forEach(b => {
                    let oldDesc = b.element.querySelector('description');
                    if (oldDesc) oldDesc.remove();
                    let descTag = xmlDoc.createElement('description');
                    descTag.textContent = `${b.hpCount} HP`;
                    b.element.appendChild(descTag);
                });

                if (uncategorizedHPs.length > 0) {
                    let othersFolder = Array.from(parent.children).find(el => el.tagName === 'Folder' && el.querySelector('name')?.textContent === 'OTHERS');
                    if (!othersFolder) {
                        othersFolder = xmlDoc.createElement('Folder');
                        const oname = xmlDoc.createElement('name');
                        oname.textContent = 'OTHERS';
                        othersFolder.appendChild(oname);
                        parent.appendChild(othersFolder); 
                    }
                    uncategorizedHPs.forEach(pm => othersFolder.appendChild(pm));
                }
            });
        }

        function autoRepositionPoints(xmlDoc) {
            const points = []; const cables = [];
            const placemarks = xmlDoc.querySelectorAll('Placemark');
            placemarks.forEach(pm => {
                const name = (pm.querySelector('name')?.textContent || '').toUpperCase();
                const parentFolder = pm.parentElement.querySelector('name')?.textContent?.toUpperCase() || '';
                const ls = pm.querySelector('LineString coordinates');
                if (ls && parentFolder === 'DISTRIBUTION CABLE') {
                    const coords = ls.textContent.trim().split(/\s+/).map(pair => {
                        const [lon, lat] = pair.split(',').map(Number);
                        return { lon, lat };
                    });
                    cables.push(coords);
                }
                const pt = pm.querySelector('Point coordinates');
                if (pt) {
                    const [lon, lat] = pt.textContent.trim().split(',').map(Number);
                    let type = null;
                    if (parentFolder === 'FAT') type = 'FAT';
                    else if (parentFolder === 'SLACK HANGER') type = 'SLACK';
                    else if (parentFolder.includes('POLE') || name.includes('POLE') || name.includes('TIANG')) type = 'POLE';
                    if (type) { points.push({ element: pt, lon, lat, type, parent: parentFolder, id: Math.random() }); }
                }
            });

            if (cables.length === 0 || points.length === 0) return;
            const processed = new Set();
            points.forEach(p1 => {
                if (processed.has(p1.id)) return;
                const cluster = [p1];
                processed.add(p1.id);
                points.forEach(p2 => {
                    if (!processed.has(p2.id)) {
                        const dist = haversine(p1, p2);
                        if (dist <= SNAP_TOLERANCE_METERS) { cluster.push(p2); processed.add(p2.id); }
                    }
                });
                let anchor = null;
                const poles = cluster.filter(p => p.type === 'POLE');
                if (poles.length > 0) {
                    poles.sort((a, b) => getMinDistToCables(a, cables) - getMinDistToCables(b, cables));
                    anchor = poles[0];
                } else {
                    cluster.sort((a, b) => getMinDistToCables(a, cables) - getMinDistToCables(b, cables));
                    anchor = cluster[0];
                }
                cluster.forEach(p => { if (p !== anchor) { p.element.textContent = `${anchor.lon},${anchor.lat},0`; } });
            });
        }

        function calculateLineLength(coordString) {
            const parts = coordString.trim().split(/\s+/);
            if (parts.length < 2) return 0;
            const points = parts.map(p => { const [lon, lat] = p.split(',').map(Number); return { lon, lat }; });
            let totalDist = 0;
            for (let i = 0; i < points.length - 1; i++) { totalDist += haversine(points[i], points[i+1]); }
            return Math.ceil(totalDist);
        }

        function injectDescriptionsAndCalc(xmlDoc) {
            const folders = xmlDoc.querySelectorAll('Folder');
            
            // --- SUBFEEDER MODE LOGIC ---
            if (CURRENT_MODE === 'subfeeder') {
                const cableFolders = Array.from(folders).filter(f => {
                    const n = f.querySelector('name');
                    return n && n.textContent.trim() === 'CABLE';
                });

                cableFolders.forEach(cableFolder => {
                    const parentLine = cableFolder.parentElement;
                    if (!parentLine) return;

                    // Get Counts from siblings
                    const siblings = Array.from(parentLine.children).filter(c => c.tagName === 'Folder');
                    const fdtFolder = siblings.find(f => f.querySelector('name')?.textContent.trim() === 'FDT');
                    const jcFolder = siblings.find(f => f.querySelector('name')?.textContent.trim() === 'JOINT CLOSURE');

                    const a = fdtFolder ? fdtFolder.getElementsByTagName('Placemark').length : 0;
                    const b = jcFolder ? jcFolder.getElementsByTagName('Placemark').length : 0;
                    
                    const y = a + b;
                    const c = a + b; // User definition: c = FDT + JC
                    const d = y * 20;

                    cableFolder.querySelectorAll('Placemark').forEach(pm => {
                        const ls = pm.querySelector('LineString coordinates');
                        if (ls) {
                            const x = calculateLineLength(ls.textContent);
                            const e = Math.ceil((x + d) * 1.05);

                            // Update Description
                            const descTag = pm.querySelector('description') || pm.appendChild(xmlDoc.createElement('description'));
                            descTag.textContent = `Deskripsi :

Total Route\t: ${x} m
Total Slack\t: ${y} unit (${a} FDT, ${b} JC, ${c} NEW) @20 m
Toleransi\t: 5%

Total Cable \t: ${x} + ${d} ( x 5%) = ${e} m`;

                            // Update Name: "Original Name - e m"
                            const nameTag = pm.querySelector('name');
                            if (nameTag) {
                                let oldName = nameTag.textContent.trim();
                                // Clean up any existing suffix to prevent duplication
                                oldName = oldName.replace(/\s*-\s*\d+\s*m(eters)?$/i, '');
                                nameTag.textContent = `${oldName} - ${e} m`;
                            }
                        }
                    });
                });
            }

            // --- CLUSTER MODE LOGIC ---
            if (CURRENT_MODE === 'cluster') {
                folders.forEach(folder => {
                    let folderName = '';
                    const nameNode = Array.from(folder.children).find(c => c.tagName === 'name');
                    if (nameNode) folderName = nameNode.textContent.trim().toUpperCase();

                    if (folderName === 'SLING WIRE') {
                        let totalMeters = 0;
                        folder.querySelectorAll('Placemark').forEach(pm => {
                            const ls = pm.querySelector('LineString coordinates');
                            if (ls) {
                                const len = calculateLineLength(ls.textContent);
                                totalMeters += len;
                                let nameTag = Array.from(pm.children).find(c => c.tagName === 'name');
                                if (!nameTag) { nameTag = xmlDoc.createElement('name'); pm.appendChild(nameTag); }
                                nameTag.textContent = `LineString — ${len} meters`;
                            }
                        });
                        if (totalMeters > 0) {
                            let descTag = Array.from(folder.children).find(c => c.tagName === 'description');
                            if (!descTag) { descTag = xmlDoc.createElement('description'); folder.appendChild(descTag); }
                            descTag.textContent = `${totalMeters} m`;
                        }
                    }
                    else if (folderName === 'DISTRIBUTION CABLE') {
                        let fatCount = 0;
                        const parentFolder = folder.parentElement;
                        if (parentFolder) {
                            const siblings = Array.from(parentFolder.children);
                            const fatFolder = siblings.find(el => el.tagName === 'Folder' && el.querySelector('name')?.textContent.trim() === 'FAT');
                            if (fatFolder) fatCount = fatFolder.getElementsByTagName('Placemark').length;
                        }
                        const b = 1; const c = fatCount; const a = b + c; const d = a * 20;
                        folder.querySelectorAll('Placemark').forEach(pm => {
                            const ls = pm.querySelector('LineString coordinates');
                            if (ls) {
                                const x = calculateLineLength(ls.textContent);
                                const e = Math.ceil((x + d) * 1.05);
                                let nameTag = Array.from(pm.children).find(child => child.tagName === 'name');
                                if (nameTag) {
                                    const oldName = nameTag.textContent.trim();
                                    const regex = /(\d+)(\s*M)$/i;
                                    if (regex.test(oldName)) { nameTag.textContent = oldName.replace(regex, e + "$2"); }
                                }
                                const descText = `Deskripsi :\n\nTotal Route \t : ${x} m\nTotal Slack\t : ${a} unit (${b} slack FDT & ${c} slack FAT) @20 m\nToleransi\t : 5%\n\n Total Length Cable  : ${x} + ${d} ( x 5%) = ${e} m`;
                                let descTag = Array.from(pm.children).find(child => child.tagName === 'description');
                                if (!descTag) { descTag = xmlDoc.createElement('description'); pm.appendChild(descTag); }
                                descTag.textContent = descText;
                            }
                        });
                    }
                    else {
                        let suffix = null;
                        if (folderName === 'FAT') suffix = ' FAT';
                        else if (folderName === 'HP COVER') suffix = ' HP';
                        else if (folderName === 'HP UNCOVER') suffix = ' HP';
                        else if (folderName.includes('EXISTING POLE')) suffix = ' EXT POLE';
                        else if (folderName.includes('NEW POLE')) suffix = ' POLE';
                        if (suffix) {
                            const count = folder.getElementsByTagName('Placemark').length;
                            if (count > 0) {
                                let descTag = Array.from(folder.children).find(c => c.tagName === 'description');
                                if (!descTag) { descTag = xmlDoc.createElement('description'); folder.appendChild(descTag); }
                                descTag.textContent = `${count}${suffix}`;
                            }
                        }
                    }
                });
            }
        }

        // --- NEW LOGIC: DETERMINE LINE NAME FROM FOLDER STRUCTURE ---
        function determineLineName(pm, rootName, structureList) {
            let curr = pm.parentElement;
            let foundLine = null;
            
            // Traverse up
            while (curr && curr.tagName === 'Folder') {
                const name = curr.querySelector('name')?.textContent.trim() || '';
                
                // If we hit the Document or the Root, stop.
                if (name === rootName) break;
                
                // Check if this folder is one of the Standard Categories (FAT, POLE, etc.)
                // If it IS NOT a standard category, it's likely our Line Folder.
                // We also need to ignore "OTHERS" or "BOUNDARY CLUSTER"
                const isStandard = structureList.includes(name) || 
                                   name === 'FDT' || 
                                   name === 'BOUNDARY CLUSTER' ||
                                   name === 'OTHERS';
                                   
                if (!isStandard && name !== '') {
                    foundLine = name;
                }
                curr = curr.parentElement;
            }
            return foundLine || 'MAIN'; // Default to MAIN if no intermediate folder found
        }

        function restructureKML(xmlDoc) {
            const kmlDoc = xmlDoc.querySelector('Document');
            const targetStructure = (CURRENT_MODE === 'subfeeder') ? STRUCTURE_SUBFEEDER : STRUCTURE_CLUSTER;

            let boundaryClusterNode = null;
            const allFolders = Array.from(xmlDoc.querySelectorAll('Folder'));
            const boundaryOriginal = allFolders.find(f => f.querySelector('name')?.textContent?.toUpperCase().includes('BOUNDARY CLUSTER'));
            
            // --- DYNAMIC ROOT DETECTION ---
            let detectedRootName = (CURRENT_MODE === 'subfeeder') ? 'SUBFEEDER ID' : 'CLUSTER ID';
            
            if (boundaryOriginal && boundaryOriginal.parentElement && boundaryOriginal.parentElement.tagName === 'Folder') {
                const parentName = boundaryOriginal.parentElement.querySelector('name');
                if (parentName) detectedRootName = parentName.textContent.trim();
            } 
            else {
                const fdtOriginal = allFolders.find(f => f.querySelector('name')?.textContent?.trim() === 'FDT');
                if (fdtOriginal && fdtOriginal.parentElement && fdtOriginal.parentElement.tagName === 'Folder') {
                    const parentName = fdtOriginal.parentElement.querySelector('name');
                    if (parentName) detectedRootName = parentName.textContent.trim();
                }
            }
            // ---------------------------------

            if (boundaryOriginal) boundaryClusterNode = boundaryOriginal.cloneNode(true);

            const allPlacemarks = Array.from(xmlDoc.querySelectorAll('Placemark')).filter(pm => {
                if (boundaryOriginal && boundaryOriginal.contains(pm)) return false;
                return true;
            });

            const fdtBucket = []; const lineBuckets = {}; const othersBucket = [];
            const addToLineBucket = (lineName, folderName, item, subFolderName = null) => {
                if (!lineBuckets[lineName]) lineBuckets[lineName] = {};
                if (!lineBuckets[lineName][folderName]) lineBuckets[lineName][folderName] = {};
                const subKey = subFolderName || 'MAIN';
                if (!lineBuckets[lineName][folderName][subKey]) lineBuckets[lineName][folderName][subKey] = [];
                lineBuckets[lineName][folderName][subKey].push(item);
            };
            const strictCableRegex = /\b\d{2,3}C\/\d{1,2}T\b/i;

            allPlacemarks.forEach(pm => {
                const internalStyle = pm.querySelector('Style');
                if(internalStyle) internalStyle.remove();

                const name = (pm.querySelector('name')?.textContent || '').toUpperCase();
                let desc = (pm.querySelector('description')?.textContent || '').toUpperCase();
                const parentFolder = pm.parentElement;
                const parentName = (parentFolder.querySelector('name')?.textContent || '').toUpperCase().trim();
                const grandParentName = (parentFolder.parentElement?.querySelector('name')?.textContent || '').toUpperCase().trim();
                
                const fullText = name + ' ' + desc;
                const isLine = pm.querySelector('LineString') !== null;
                
                // --- V13: USE FOLDER STRUCTURE FOR LINE NAME ---
                let lineName = 'MAIN';
                if (CURRENT_MODE === 'cluster') {
                    lineName = determineLineName(pm, detectedRootName, targetStructure);
                }

                let targetType = 'UNKNOWN';
                let subFolderName = null;

                if (parentName.includes('HP COVER')) { targetType = 'HP COVER'; } 
                else if (grandParentName.includes('HP COVER')) { targetType = 'HP COVER'; subFolderName = parentName; } 
                else if (parentName.includes('HP UNCOVER')) targetType = 'HP UNCOVER';
                else if (grandParentName.includes('HP UNCOVER')) { targetType = 'HP UNCOVER'; subFolderName = parentName; }
                
                if (targetType === 'UNKNOWN') {
                    if (CURRENT_MODE === 'subfeeder') {
                        if (isLine && (strictCableRegex.test(fullText) || name.includes('CABLE') || parentName.includes('CABLE'))) { targetType = 'CABLE'; }
                        else if (!isLine) {
                            if (name.includes('JC') || fullText.includes('JOINT CLOSURE')) { 
                                targetType = 'JOINT CLOSURE'; 
                            } else if (/\b(288C|144C|96C|72C|48C)\b/.test(fullText)) { 
                                targetType = 'FDT'; 
                            }
                        }
                        if (targetType === 'UNKNOWN') {
                             const poleMatch = targetStructure.find(type => type.includes('POLE') && (name.includes(type) || parentName.includes(type) || desc.includes(type)));
                             if (poleMatch) targetType = poleMatch;
                        }
                    } else {
                        if (!isLine && (name.includes('FDT') || desc.includes('FDT') || parentName.includes('FDT') || (/\b(288C|144C|96C|72C|48C)\b/.test(fullText) && !strictCableRegex.test(fullText)))) { targetType = 'FDT_GLOBAL'; }
                        else if (isLine && (strictCableRegex.test(fullText) || name.includes('CABLE') || parentName.includes('DISTRIBUTION'))) { targetType = 'DISTRIBUTION CABLE'; }
                        else {
                             const match = targetStructure.find(type => name.includes(type) || parentName.includes(type) || desc.includes(type));
                             if (match) targetType = match;
                        }
                    }
                }

                if (targetType === 'UNKNOWN') {
                    if (name.includes('SLING')) targetType = (CURRENT_MODE === 'subfeeder') ? 'UNKNOWN' : 'SLING WIRE';
                    else if (name.includes('SLACK') || parentName.includes('SLACK')) targetType = 'SLACK HANGER';
                    else {
                        const match = targetStructure.find(type => name.includes(type) || parentName.includes(type));
                        if(match) targetType = match;
                    }
                }

                const PRESERVE_DESC = ['BOUNDARY FAT', 'DISTRIBUTION CABLE', 'FDT', 'CABLE', 'FDT_GLOBAL'];
                if (!PRESERVE_DESC.includes(targetType)) {
                    const descTag = pm.querySelector('description');
                    if (descTag) descTag.remove();
                }

                pm.remove();
                if (targetType === 'FDT_GLOBAL' && CURRENT_MODE === 'cluster') fdtBucket.push(pm);
                else if (targetType !== 'UNKNOWN') addToLineBucket(lineName, targetType, pm, subFolderName);
                else othersBucket.push(pm);
            });

            while (kmlDoc.firstChild) kmlDoc.removeChild(kmlDoc.firstChild);
            const root = xmlDoc.createElement('Folder');
            root.appendChild(createName(xmlDoc, detectedRootName)); 

            if (boundaryClusterNode) root.appendChild(boundaryClusterNode);
            if (fdtBucket.length > 0) root.appendChild(createFolder(xmlDoc, 'FDT', fdtBucket));

            if (CURRENT_MODE === 'subfeeder') {
                const mainData = lineBuckets['MAIN'] || {};
                targetStructure.forEach(folderName => {
                    const subData = mainData[folderName];
                    if (subData) {
                        const folder = xmlDoc.createElement('Folder');
                        folder.appendChild(createName(xmlDoc, folderName));
                        if (subData['MAIN']) subData['MAIN'].forEach(i => folder.appendChild(i));
                        Object.keys(subData).forEach(k => { if (k !== 'MAIN') folder.appendChild(createFolder(xmlDoc, k, subData[k])); });
                        root.appendChild(folder);
                    } else { root.appendChild(createFolder(xmlDoc, folderName, [])); }
                });
            } else {
                Object.keys(lineBuckets).sort().forEach(ln => {
                    // IF lineName is 'MAIN', it means the items were directly under Root (or no Line folder). 
                    // To prevent flattening, if it is 'MAIN', we attach directly to root.
                    // BUT, if the user had "LINE A", we create "LINE A".
                    
                    let targetContainer = root;
                    if (ln !== 'MAIN') {
                        const lnFolder = xmlDoc.createElement('Folder');
                        lnFolder.appendChild(createName(xmlDoc, ln));
                        root.appendChild(lnFolder);
                        targetContainer = lnFolder;
                    }

                    targetStructure.forEach(folderName => {
                        const subData = lineBuckets[ln][folderName];
                        if (subData) {
                            const folder = xmlDoc.createElement('Folder');
                            folder.appendChild(createName(xmlDoc, folderName));
                            if (subData['MAIN']) subData['MAIN'].forEach(i => folder.appendChild(i));
                            Object.keys(subData).forEach(k => { if (k !== 'MAIN') folder.appendChild(createFolder(xmlDoc, k, subData[k])); });
                            targetContainer.appendChild(folder);
                        } else { targetContainer.appendChild(createFolder(xmlDoc, folderName, [])); }
                    });
                });
            }
            if (othersBucket.length > 0) root.appendChild(createFolder(xmlDoc, 'OTHERS', othersBucket));
            kmlDoc.appendChild(root);
            return { mode: CURRENT_MODE, lines: Object.keys(lineBuckets), rootName: detectedRootName };
        }

        function createName(xml, text) { const n = xml.createElement('name'); n.textContent = text; return n; }
        function createFolder(xml, name, items) { 
            const f = xml.createElement('Folder'); 
            f.appendChild(createName(xml, name)); 
            items.forEach(i => f.appendChild(i)); 
            return f; 
        }

        function applyStyles(xmlDoc) {
            const placemarks = xmlDoc.querySelectorAll('Placemark');
            const doc = xmlDoc.querySelector('Document');
            const stylesCreated = new Set();
            const styleB = xmlDoc.createElement('Style'); styleB.id = 'style_boundary';
            styleB.innerHTML = `<LineStyle><color>4dffffff</color><width>2</width></LineStyle><PolyStyle><color>4dffffff</color></PolyStyle>`;
            doc.appendChild(styleB);

            placemarks.forEach(pm => {
                const name = (pm.querySelector('name')?.textContent || '').toUpperCase();
                const desc = (pm.querySelector('description')?.textContent || '').toUpperCase();
                const fullText = name + ' ' + desc;
                const folderName = pm.parentElement.querySelector('name')?.textContent || '';
                const grandParentName = pm.parentElement.parentElement?.querySelector('name')?.textContent || '';

                if (folderName.includes('BOUNDARY CLUSTER')) { setStyle(pm, 'style_boundary'); return; }
                let rule = null;

                if (CURRENT_MODE === 'cluster') {
                    rule = RULES_CLUSTER.find(r => {
                        if (r.folder !== '-' && r.folder === folderName) return true;
                        if (folderName === 'DISTRIBUTION CABLE' && r.line !== '-' && fullText.includes(r.line)) return true;
                        if (r.placemark !== '-' && fullText.includes(r.placemark)) return true;
                        return false;
                    });
                    if (!rule) {
                        if (grandParentName.includes('HP COVER')) rule = RULES_CLUSTER.find(r => r.folder === 'HP COVER');
                        else if (grandParentName.includes('HP UNCOVER')) rule = RULES_CLUSTER.find(r => r.folder === 'HP UNCOVER');
                    }
                } else {
                    if (folderName === 'CABLE') {
                        const coreColors = { '288C': '#FFAA00', '144C': '#AAFF00', '96C': '#FF0000', '48C': '#AA00FF', '24C': '#00FF00' };
                        const match = Object.keys(coreColors).find(k => fullText.includes(k));
                        rule = { colorCode: match ? coreColors[match] : '#00AAFF', styleLink: '-', placemark: '-' };
                    }
                    else if (folderName === 'FDT') {
                        const coreMatch = fullText.match(/\b(\d+)C\b/);
                        const core = coreMatch ? coreMatch[0] : '48C';
                        // --- V10 FIX: 72C color is now Blue ---
                        const coreMap = { '288C': '#FFAA00', '144C': '#AAFF00', '96C': '#FF0000', '72C': '#0000FF', '48C': '#AA00FF', '36C': '#FF00FF', '24C': '#00FF00' };
                        const color = coreMap[core] || '#AA00FF';
                        rule = { colorCode: color, styleLink: 'http://maps.google.com/mapfiles/kml/shapes/cross-hairs.png', placemark: 'FDT_' + core };
                    }
                    else if (folderName === 'JOINT CLOSURE') {
                        const coreMatch = fullText.match(/\b(\d+)C\b/);
                        const core = coreMatch ? coreMatch[0] : '48C';
                        // --- V10 FIX: 72C color is now Blue ---
                        const coreMap = { '288C': '#FFAA00', '144C': '#AAFF00', '96C': '#FF0000', '72C': '#0000FF', '48C': '#AA00FF', '36C': '#FF00FF', '24C': '#00FF00' };
                        const color = coreMap[core] || '#AA00FF';
                        rule = { colorCode: color, styleLink: 'http://maps.google.com/mapfiles/kml/shapes/forbidden.png', placemark: 'JC_' + core };
                    }
                    else if (folderName.includes('POLE')) {
                        let pColor = '#550000';
                        const upperFolder = folderName.toUpperCase();
                        if (upperFolder.includes('NEW')) {
                            if (upperFolder.includes('9-')) pColor = '#FF0000';
                            else if (upperFolder.includes('7-5') || upperFolder.includes('7-4')) pColor = '#00FF00';
                            else if (upperFolder.includes('7-3')) pColor = '#00FFFF';
                            else if (upperFolder.includes('7-2.5')) pColor = '#AA00FF';
                        }
                        rule = { colorCode: pColor, styleLink: 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png', placemark: '-' };
                    }
                    else {
                        rule = RULES_SUBFEEDER.find(r => r.folder === folderName);
                    }
                }

                if (rule) {
                    const safeName = rule.placemark !== '-' ? rule.placemark : folderName;
                    const styleId = `style_${rule.colorCode.replace('#','')}_${safeName.replace(/[^a-z0-9]/gi,'')}_${Math.floor(Math.random()*1000)}`;
                    if (!stylesCreated.has(styleId)) {
                        const style = xmlDoc.createElement('Style'); style.id = styleId;
                        const kmlColor = 'ff' + rule.colorCode.replace('#', '').match(/.{2}/g).reverse().join('');
                        let styleContent = `<LabelStyle><color>${kmlColor}</color><scale>${TEXT_SIZE}</scale></LabelStyle>`;
                        if (rule.styleLink !== '-') styleContent += `<IconStyle><color>${kmlColor}</color><scale>1.1</scale><Icon><href>${rule.styleLink}</href></Icon></IconStyle>`;
                        styleContent += `<LineStyle><color>${kmlColor}</color><width>2</width></LineStyle><PolyStyle><color>66${kmlColor.substring(2)}</color></PolyStyle>`;
                        style.innerHTML = styleContent;
                        doc.appendChild(style);
                        stylesCreated.add(styleId);
                    }
                    setStyle(pm, styleId);
                }
            });
        }

        function setStyle(pm, id) {
            let oldUrl = pm.querySelector('styleUrl');
            if(oldUrl) oldUrl.remove();

            let url = pm.ownerDocument.createElement('styleUrl'); 
            url.textContent = '#' + id;
            pm.appendChild(url);
        }

        function displayTree(result) {
            const list = document.getElementById('folderList');
            const mode = result.mode;
            let html = `<div class="tree-item"><span class="tree-folder" style="color:#aaa">BOUNDARY CLUSTER</span></div>`;
            if (result.lines.includes('FDT') || mode === 'cluster') html += `<div class="tree-item"><span class="tree-folder">FDT</span></div>`;
            
            html += `<div class="tree-item"><span class="tree-folder" style="color:#fff; border-bottom:1px solid #333; display:inline-block; margin-bottom:5px;">ROOT: ${result.rootName}</span></div>`;
            
            result.lines.forEach(l => { 
                if (l !== 'FDT' && l !== 'MAIN') {
                    html += `<div class="tree-item"><span class="tree-folder">${l}</span></div>`; 
                }
            });
            
            list.innerHTML = html;
            document.getElementById('preview').classList.remove('hidden');
        }
    </script>
</body>
</html>
